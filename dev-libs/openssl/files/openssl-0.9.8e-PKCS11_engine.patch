diff -urN openssl-0.9.8e/engines/cryptoki.h openssl-0.9.8e.new/engines/cryptoki.h
--- openssl-0.9.8e/engines/cryptoki.h	1970-01-01 10:00:00.000000000 +1000
+++ openssl-0.9.8e.new/engines/cryptoki.h	2008-06-13 09:45:21.000000000 +1000
@@ -0,0 +1,88 @@
+/* cryptoki.h include file for PKCS #11. */
+/* $Revision: 1.1 $ */
+
+/* License to copy and use this software is granted provided that it is
+ * identified as "RSA Security Inc. PKCS #11 Cryptographic Token Interface
+ * (Cryptoki)" in all material mentioning or referencing this software.
+
+ * License is also granted to make and use derivative works provided that
+ * such works are identified as "derived from the RSA Security Inc. PKCS #11
+ * Cryptographic Token Interface (Cryptoki)" in all material mentioning or 
+ * referencing the derived work.
+
+ * RSA Security Inc. makes no representations concerning either the 
+ * merchantability of this software or the suitability of this software for
+ * any particular purpose. It is provided "as is" without express or implied
+ * warranty of any kind.
+ */
+
+/* 
+  Modified IBM 2008. Multiplatform support
+ */
+
+#ifndef ___CRYPTOKI_H_INC___
+#define ___CRYPTOKI_H_INC___
+
+#pragma pack(push, cryptoki, 1)
+
+#if defined(AIX) || defined(HPUX) || defined(SOLARIS) || defined(LINUX) || defined(LINUX64) || defined(_IA64) | defined(AIX64) || defined(__LP64__)
+
+#  define CK_ENTRY
+#  define CK_CALLBACK_ENTRY
+#  define CK_IMPORT_SPEC
+#  define CK_CALL_SPEC
+
+#elif defined(OS2)
+
+#  define CK_ENTRY
+#  define CK_CALLBACK_ENTRY _Optlink
+#  define CK_IMPORT_SPEC
+#  define CK_CALL_SPEC
+
+#elif defined(WIN32)
+
+#  define CK_ENTRY __declspec( dllexport )
+#  define CK_CALLBACK_ENTRY
+#  define CK_IMPORT_SPEC __declspec(dllimport)
+#  define CK_CALL_SPEC __cdecl
+
+
+#else
+
+#  error "Includes not defined for this platform."
+
+#endif
+
+/* Define CRYPTOKI_EXPORTS during the build of cryptoki libraries. Do
+ * not define it in applications.
+ */
+#ifdef CRYPTOKI_EXPORTS
+/* Specified that the function is an exported DLL entry point. */
+#define CK_EXPORT_SPEC __declspec(dllexport) 
+#else
+#define CK_EXPORT_SPEC CK_IMPORT_SPEC 
+#endif
+
+#define CK_PTR *
+
+#define CK_DEFINE_FUNCTION(returnType, name) \
+  returnType CK_EXPORT_SPEC CK_CALL_SPEC name
+
+#define CK_DECLARE_FUNCTION(returnType, name) \
+  returnType CK_EXPORT_SPEC CK_CALL_SPEC name
+
+#define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
+  returnType CK_IMPORT_SPEC (CK_CALL_SPEC CK_PTR name)
+
+#define CK_CALLBACK_FUNCTION(returnType, name)  \
+    returnType (CK_CALL_SPEC CK_PTR name)    
+
+#ifndef NULL_PTR
+#define NULL_PTR 0
+#endif
+
+#include "pkcs11.h"
+
+#pragma pack(pop, cryptoki)
+
+#endif /* ___CRYPTOKI_H_INC___ */
diff -urN openssl-0.9.8e/engines/e_pkcs11.c openssl-0.9.8e.new/engines/e_pkcs11.c
--- openssl-0.9.8e/engines/e_pkcs11.c	1970-01-01 10:00:00.000000000 +1000
+++ openssl-0.9.8e.new/engines/e_pkcs11.c	2008-06-13 11:10:12.000000000 +1000
@@ -0,0 +1,3042 @@
+/* hw_pkcs11.c (replace hw_trustway.c) */
+/*
+ * PKCS#11 engine for the OpenSSL project 2002
+ * Developped by Bull Trustway R&D Networking & Security
+ * Introduced and tested with Bull TrustWay CC2000 crypto hardware
+ * Afchine.Madjlessi@bull.net Bull S.A. France
+ * http://www.servers.bull.com/trustway
+ *
+ * ChangLog:
+ *      * 8/15/2005 Fixes suggested by opencryptoki-engines list
+ *	* 1/1/2004 Modified to support digests, ciphers and openCryptoki
+ *	  http://www.sf.net/projects/opencryptoki
+ *	- Serge Hallyn <serue@us.ibm.com>
+ *	- Kent Yoder <yoder1@us.ibm.com>
+ *      - Peter Waltenberg <pwalten@au1.ibm.com>
+ *	(C) International Business Machines Corporation 2004, 2005
+ */
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <openssl/e_os2.h>
+//#if !defined(OPENSSL_SYS_MSDOS) || defined(__DJGPP__)
+#include <sys/types.h>
+#include <unistd.h>
+//#else
+//#include <process.h>
+//typedef int pid_t;
+//#endif
+
+#include <openssl/engine.h>
+#include <openssl/dso.h>
+#include <openssl/err.h>
+#include <stdio.h>
+#include <openssl/bn.h>
+#include <openssl/pem.h>
+#include <openssl/rsa.h>
+#include <openssl/rand.h>
+#include <openssl/objects.h>
+#include <openssl/x509.h>
+#include <openssl/md5.h>
+#include <openssl/ripemd.h>
+#include <pthread.h>
+
+#ifndef OPENSSL_NO_HW
+#ifndef OPENSSL_NO_HW_PKCS11
+
+
+
+#include "cryptoki.h"
+#include "e_pkcs11_err.c"
+#include "e_pkcs11.h"
+/* SHA224, CAMELLIA */
+#include "pkcs-11v2-20a3.h"
+
+/* Constants used when creating the ENGINE */
+static const char *engine_pkcs11_id = "pkcs11";
+static const char *engine_pkcs11_name = "PKCS#11 hardware engine support";
+
+static int bind_pkcs11(ENGINE *e);
+
+/* ENGINE level stuff */
+static int pkcs11_init(ENGINE *e);
+static int pkcs11_finish(ENGINE *e);
+static int pkcs11_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)());
+static int pkcs11_destroy(ENGINE *e);
+
+#ifndef OPENSSL_NO_RSA
+/* RSA stuff */
+static int pkcs11_RSA_public_encrypt(int flen, const unsigned char *from, unsigned char *to,
+		RSA *rsa, int padding);
+static int pkcs11_RSA_private_encrypt(int flen, const unsigned char *from, unsigned char *to,
+		RSA *rsa, int padding);
+static int pkcs11_RSA_public_decrypt(int flen, const unsigned char *from, unsigned char *to,
+		RSA *rsa, int padding);
+static int pkcs11_RSA_private_decrypt(int flen, const unsigned char *from, unsigned char *to,
+		RSA *rsa, int padding);
+static int pkcs11_RSA_init(RSA *rsa);
+static int pkcs11_RSA_finish(RSA *rsa);
+static int pkcs11_RSA_sign(int type, const unsigned char *m, unsigned int m_len,
+		unsigned char *sigret, unsigned int *siglen, const RSA *rsa);
+static int pkcs11_RSA_verify(int dtype, const unsigned char *m, unsigned int m_len,
+		unsigned char *sigbuf, unsigned int siglen, const RSA *rsa);
+static int pkcs11_RSA_generate_key(RSA *rsa, int bits, unsigned long e_value,
+		void (*callback)(int,int,void *), void *cb_arg);
+
+static EVP_PKEY *pkcs11_load_privkey(ENGINE*, const char* pubkey_file,
+		UI_METHOD *ui_method, void *callback_data);
+static EVP_PKEY *pkcs11_load_pubkey(ENGINE*, const char* pubkey_file,
+		UI_METHOD *ui_method, void *callback_data);
+
+CK_OBJECT_HANDLE pkcs11_FindOrCreateKey(CK_SESSION_HANDLE h, RSA* rsa, CK_OBJECT_CLASS oKey, CK_BBOOL fKeyCreate);
+/* exported functions (not member of ENGINE inteface) */
+RSA* pkcs11_RSA_generate_tmp_key(int bits,unsigned long e_value,void (*callback)(int,int,void *),void *cb_arg);
+#endif
+
+/* RAND stuff */
+static void pkcs11_rand_seed(const void *buf, int num);
+static void pkcs11_rand_add(const void *buf, int num, double add_entropy);
+static void pkcs11_rand_cleanup(void);
+static int pkcs11_rand_bytes(unsigned char *buf, int num);
+static int pkcs11_rand_status(void);
+
+/* cipher function prototypes */
+static inline int pkcs11_init_key(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+		const unsigned char *iv, int enc, int alg);
+static inline int pkcs11_cipher(EVP_CIPHER_CTX * ctx, unsigned char *out,
+		const unsigned char *in, unsigned int inlen);
+static int pkcs11_cipher_cleanup(EVP_CIPHER_CTX *ctx);
+
+static int pkcs11_des_init_key(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+		const unsigned char *iv, int enc);
+static int pkcs11_tdes_init_key(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+		const unsigned char *iv, int enc);
+static int pkcs11_aes_init_key(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+		const unsigned char *iv, int enc);
+/* End cipher function prototypes */
+
+/* Digest function prototypes */
+static inline int pkcs11_digest_init(EVP_MD_CTX *ctx, int alg);
+static int pkcs11_digest_update(EVP_MD_CTX *ctx, const void *in, ulong len);
+static int pkcs11_digest_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in);
+static int pkcs11_digest_finish(EVP_MD_CTX *ctx, unsigned char *md);
+static inline int pkcs11_digest_cleanup(EVP_MD_CTX *ctx);
+
+static inline int pkcs11_sha1_init(EVP_MD_CTX *ctx);
+static inline int pkcs11_sha224_init(EVP_MD_CTX *ctx);
+static inline int pkcs11_sha256_init(EVP_MD_CTX *ctx);
+static inline int pkcs11_sha384_init(EVP_MD_CTX *ctx);
+static inline int pkcs11_sha512_init(EVP_MD_CTX *ctx);
+static inline int pkcs11_md5_init(EVP_MD_CTX *ctx);
+static inline int pkcs11_ripemd_init(EVP_MD_CTX *ctx);
+/* End digest function prototypes */
+
+static int pre_init_pkcs11(ENGINE *e);
+static int pkcs11_engine_ciphers(ENGINE * e, const EVP_CIPHER ** cipher,
+		const int **nids, int nid);
+static int pkcs11_engine_digests(ENGINE * e, const EVP_MD ** digest,
+		const int **nids, int nid);
+
+
+/* Number of NID's that exist in OpenSSL */
+#define NUM_NID 650
+int pkcs11_implemented_ciphers[NUM_NID] = { 0, };
+int pkcs11_implemented_digests[NUM_NID] = { 0, };
+pid_t mypid = -1;
+
+/* The definitions for control commands specific to this engine */
+#define PKCS11_CMD_SO_PATH		ENGINE_CMD_BASE
+#define PKCS11_CMD_USER_PIN             (ENGINE_CMD_BASE+1)
+static const ENGINE_CMD_DEFN pkcs11_cmd_defns[] =
+{
+	{ PKCS11_CMD_SO_PATH,
+		"SO_PATH",
+		"Specifies the path to the 'pkcs#11' shared library",
+		ENGINE_CMD_FLAG_STRING
+	},
+	{ PKCS11_CMD_USER_PIN,
+		"USER_PIN",
+		"Provides the user PIN for devices that need one to function",
+		ENGINE_CMD_FLAG_STRING
+	},
+	{0, NULL, NULL, 0}
+};
+
+
+
+#ifdef OPENSSL_NO_DYNAMIC_ENGINE
+static ENGINE *engine_pkcs11(void)
+{
+   ENGINE *ret = ENGINE_new();
+   if(!ret) {
+      return NULL;
+   }   
+   if(!bind_helper(ret)) {
+      ENGINE_free(ret);
+      return NULL;
+   }
+   return ret;
+}
+                                                 
+void ENGINE_load_pkcs11(void)
+{
+   ENGINE *toadd = engine_pkcs11();
+   if(!toadd) return;
+   ENGINE_add(toadd);
+   ENGINE_free(toadd);
+   ERR_clear_error();
+}
+#else
+static int bind_helper(ENGINE *e, const char *id)
+{
+  if((NULL != id) && (strcmp(id, engine_pkcs11_id) != 0))
+    return 0;
+  return(bind_pkcs11(e));
+}       
+IMPLEMENT_DYNAMIC_CHECK_FN()
+IMPLEMENT_DYNAMIC_BIND_FN(bind_helper)
+#endif                                                                        
+                                        
+/*
+ * Comments on approaches:
+ *   At the moment, ciphers and digests are treated differently.
+ *
+ *   For ciphers, we use cipher_init to initialize the cryptoki
+ *    cipher action, and update to encrypt.  There is no finalize
+ *    or cleanup.
+ *
+ *   For digests, we use digest_init to initialize a context
+ *    struct, digest_update to append data to the data field within
+ *    that struct, finalize() to call C_Digest() on all the data
+ *    at once, and cleanup() to free the context struct.
+ *   The digest approach is part of the openbsd implementation.  We
+ *    do not do anything about the potential EVP_MD_FLAG_ONESHOT
+ *    condition in update(), because openssl will still call finalize
+ *    after that.
+ */
+
+/* 
+ * Each cipher/digest action requires a new session.  We store the
+ * session and its token in the context->cipher_data void* using
+ * this struct
+ */
+struct token_session {
+	struct _token *token;
+	CK_SESSION_HANDLE session;
+};
+
+/*
+ * For digests:
+ * We follow the example of openbsd_hw.c: digest_update just builds up
+ * an array of what to process.  final() runs the digest on that data.
+ * TODO: In order to prevent memory problems when we have a huge input,
+ * we may want to trigger a do_digest when len gets too big.
+ */
+#define PKCS11_DIGEST_BLOCK_SIZE 4096
+struct pkcs11_digest_ctx {
+	int alg;
+	char *data;
+	int len;
+	int size; /* alloc'd size of data so far */
+	int *ref_cnt; /* number of references to this digest operation */
+};
+
+/********/
+
+#define CIPHER_DATA(ctx) ((struct token_session *)(ctx->cipher_data))
+#define MD_DATA(ctx) ((struct token_session *)(ctx->md_data))
+
+static int num_cipher_nids = 0;
+static int num_digest_nids = 0;
+
+const EVP_CIPHER pkcs11_des_ecb = {
+	NID_des_ecb,		/* NID */
+	8,			/* Block size */
+	8,			/* Key len */
+	8,			/* IV len */
+	EVP_CIPH_ECB_MODE,	/* flags */
+	pkcs11_des_init_key,	/* init */
+	pkcs11_cipher,	/* do_cipher */
+	pkcs11_cipher_cleanup,	/* cleanup */
+	sizeof(struct token_session),
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,			/* misc ctrl ops */
+	NULL			/* app data (ctx->cipher_data) */
+};
+
+const EVP_CIPHER pkcs11_des_cbc = {
+	NID_des_cbc,		/* NID */
+	8,			/* Block size */
+	8,			/* Key len */
+	8,			/* IV len */
+	EVP_CIPH_CBC_MODE,	/* flags */
+	pkcs11_des_init_key,	/* init */
+	pkcs11_cipher,	/* do_cipher */
+	pkcs11_cipher_cleanup,	/* cleanup */
+	sizeof(struct token_session),	/* sizeof(ctx->cipher_data) */
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,			/* misc ctrl ops */
+	NULL			/* app data (ctx->cipher_data) */
+};
+
+const EVP_CIPHER pkcs11_tdes_ecb = {
+	NID_des_ede3_ecb,	/* NID */
+	8,			/* Block size */
+	24,			/* Key len */
+	8,			/* IV len */
+	EVP_CIPH_ECB_MODE,	/* flags */
+	pkcs11_tdes_init_key,	/* init */
+	pkcs11_cipher,	/* do_cipher */
+	pkcs11_cipher_cleanup,	/* cleanup */
+	sizeof(struct token_session),	/* sizeof(ctx->cipher_data) */
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,			/* misc ctrl ops */
+	NULL			/* app data (ctx->cipher_data) */
+};
+
+const EVP_CIPHER pkcs11_tdes_cbc = {
+	NID_des_ede3_cbc,	/* NID */
+	8,			/* Block size */
+	24,			/* Key len */
+	8,			/* IV len */
+	EVP_CIPH_CBC_MODE,	/* flags */
+	pkcs11_tdes_init_key,	/* init */
+	pkcs11_cipher,	/* do_cipher */
+	pkcs11_cipher_cleanup,	/* cleanup */
+	sizeof(struct token_session),	/* sizeof(ctx->cipher_data) */
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,			/* misc ctrl ops */
+	NULL			/* app data (ctx->cipher_data) */
+};
+
+/* AES ECB */
+const EVP_CIPHER pkcs11_aes_128_ecb = {
+	NID_aes_128_cbc,	/* NID */
+	16,			/* Block size */
+	16,			/* Key len */
+	16,			/* IV len */
+	EVP_CIPH_ECB_MODE,	/* flags */
+	pkcs11_aes_init_key,	/* init */
+	pkcs11_cipher,	/* do_cipher */
+	pkcs11_cipher_cleanup,	/* cleanup */
+	sizeof(struct token_session),	/* sizeof(ctx->cipher_data) */
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,			/* misc ctrl ops */
+	NULL			/* app data (ctx->cipher_data) */
+};
+const EVP_CIPHER pkcs11_aes_192_ecb = {
+	NID_aes_192_ecb,	/* NID */
+	24,			/* Block size */
+	24,			/* Key len */
+	24,			/* IV len */
+	EVP_CIPH_ECB_MODE,	/* flags */
+	pkcs11_aes_init_key,	/* init */
+	pkcs11_cipher,	/* do_cipher */
+	pkcs11_cipher_cleanup,	/* cleanup */
+	sizeof(struct token_session),	/* sizeof(ctx->cipher_data) */
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,			/* misc ctrl ops */
+	NULL			/* app data (ctx->cipher_data) */
+};
+const EVP_CIPHER pkcs11_aes_256_ecb = {
+	NID_aes_256_ecb,	/* NID */
+	32,			/* Block size */
+	32,			/* Key len */
+	32,			/* IV len */
+	EVP_CIPH_ECB_MODE,	/* flags */
+	pkcs11_aes_init_key,	/* init */
+	pkcs11_cipher,	/* do_cipher */
+	pkcs11_cipher_cleanup,	/* cleanup */
+	sizeof(struct token_session),	/* sizeof(ctx->cipher_data) */
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,			/* misc ctrl ops */
+	NULL			/* app data (ctx->cipher_data) */
+};
+
+/* AES CBC */
+const EVP_CIPHER pkcs11_aes_128_cbc = {
+	NID_aes_128_cbc,	/* NID */
+	16,			/* Block size */
+	16,			/* Key len */
+	16,			/* IV len */
+	EVP_CIPH_CBC_MODE,	/* flags */
+	pkcs11_aes_init_key,	/* init */
+	pkcs11_cipher,	/* do_cipher */
+	pkcs11_cipher_cleanup,	/* cleanup */
+	sizeof(struct token_session),	/* sizeof(ctx->cipher_data) */
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,			/* misc ctrl ops */
+	NULL			/* app data (ctx->cipher_data) */
+};
+const EVP_CIPHER pkcs11_aes_192_cbc = {
+	NID_aes_192_cbc,	/* NID */
+	24,			/* Block size */
+	24,			/* Key len */
+	24,			/* IV len */
+	EVP_CIPH_CBC_MODE,	/* flags */
+	pkcs11_aes_init_key,	/* init */
+	pkcs11_cipher,	/* do_cipher */
+	pkcs11_cipher_cleanup,	/* cleanup */
+	sizeof(struct token_session),	/* sizeof(ctx->cipher_data) */
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,			/* misc ctrl ops */
+	NULL			/* app data (ctx->cipher_data) */
+};
+const EVP_CIPHER pkcs11_aes_256_cbc = {
+	NID_aes_256_cbc,	/* NID */
+	32,			/* Block size */
+	32,			/* Key len */
+	32,			/* IV len */
+	EVP_CIPH_CBC_MODE,	/* flags */
+	pkcs11_aes_init_key,	/* init */
+	pkcs11_cipher,	/* do_cipher */
+	pkcs11_cipher_cleanup,	/* cleanup */
+	sizeof(struct token_session),	/* sizeof(ctx->cipher_data) */
+	EVP_CIPHER_set_asn1_iv,
+	EVP_CIPHER_get_asn1_iv,
+	NULL,			/* misc ctrl ops */
+	NULL			/* app data (ctx->cipher_data) */
+};
+
+/* Message Digests */
+const EVP_MD pkcs11_sha1 = {
+       NID_sha1,
+       NID_sha1WithRSAEncryption,
+       SHA_DIGEST_LENGTH,
+       0,
+       pkcs11_sha1_init,
+       pkcs11_digest_update,
+       pkcs11_digest_finish, /* final */
+       pkcs11_digest_copy,
+       pkcs11_digest_cleanup, /* cleanup */
+       EVP_PKEY_RSA_method,
+       SHA_CBLOCK,
+       sizeof(struct pkcs11_digest_ctx)
+};
+const EVP_MD pkcs11_sha224 = {
+       NID_sha224,
+       NID_sha224WithRSAEncryption,
+       SHA224_DIGEST_LENGTH,
+       0,
+       pkcs11_sha224_init,
+       pkcs11_digest_update,
+       pkcs11_digest_finish, /* final */
+       pkcs11_digest_copy,
+       pkcs11_digest_cleanup, /* cleanup */
+       EVP_PKEY_RSA_method,
+       SHA256_CBLOCK,
+       sizeof(struct pkcs11_digest_ctx)
+};
+const EVP_MD pkcs11_sha256 = {
+       NID_sha256,
+       NID_sha256WithRSAEncryption,
+       SHA256_DIGEST_LENGTH,
+       0,
+       pkcs11_sha256_init,
+       pkcs11_digest_update,
+       pkcs11_digest_finish, /* final */
+       pkcs11_digest_copy,
+       pkcs11_digest_cleanup, /* cleanup */
+       EVP_PKEY_RSA_method,
+       SHA256_CBLOCK,
+       sizeof(struct pkcs11_digest_ctx)
+};
+const EVP_MD pkcs11_sha384 = {
+       NID_sha384,
+       NID_sha384WithRSAEncryption,
+       SHA384_DIGEST_LENGTH,
+       0,
+       pkcs11_sha384_init,
+       pkcs11_digest_update,
+       pkcs11_digest_finish, /* final */
+       pkcs11_digest_copy,
+       pkcs11_digest_cleanup, /* cleanup */
+       EVP_PKEY_RSA_method,
+       SHA512_CBLOCK,
+       sizeof(struct pkcs11_digest_ctx)
+};
+const EVP_MD pkcs11_sha512 = {
+       NID_sha512,
+       NID_sha512WithRSAEncryption,
+       SHA512_DIGEST_LENGTH,
+       0,
+       pkcs11_sha512_init,
+       pkcs11_digest_update,
+       pkcs11_digest_finish, /* final */
+       pkcs11_digest_copy,
+       pkcs11_digest_cleanup, /* cleanup */
+       EVP_PKEY_RSA_method,
+       SHA512_CBLOCK,
+       sizeof(struct pkcs11_digest_ctx)
+};
+
+const EVP_MD pkcs11_md5 = {
+       NID_md5,
+       NID_md5WithRSAEncryption,
+       MD5_DIGEST_LENGTH,
+       0,
+       pkcs11_md5_init,
+       pkcs11_digest_update,
+       pkcs11_digest_finish, /* final */
+       pkcs11_digest_copy,
+       pkcs11_digest_cleanup,  /* cleanup */
+       EVP_PKEY_RSA_method,
+       MD5_CBLOCK,
+       sizeof(struct pkcs11_digest_ctx)
+};
+
+const EVP_MD pkcs11_ripemd = {
+       NID_ripemd160,
+       NID_ripemd160WithRSA,
+       RIPEMD160_DIGEST_LENGTH,
+       0, /* flags */
+       pkcs11_ripemd_init,
+       pkcs11_digest_update,
+       pkcs11_digest_finish,  /* final */
+       pkcs11_digest_copy,
+       pkcs11_digest_cleanup,  /* cleanup */
+       EVP_PKEY_RSA_method,
+       RIPEMD160_CBLOCK,
+       sizeof(struct pkcs11_digest_ctx)
+};
+
+/********/
+
+
+#ifndef OPENSSL_NO_RSA
+static RSA_METHOD pkcs11_rsa =
+{
+	"PKCS#11 RSA",
+	pkcs11_RSA_public_encrypt,                     /* rsa_pub_encrypt */
+	pkcs11_RSA_public_decrypt,                     /* rsa_pub_decrypt */
+	pkcs11_RSA_private_encrypt,                    /* rsa_priv_encrypt */
+	pkcs11_RSA_private_decrypt,                    /* rsa_priv_decrypt */
+	NULL,                                          /* rsa_mod_exp */   
+	NULL,                                          /* bn_mod_exp */
+	pkcs11_RSA_init,                               /* init */
+	pkcs11_RSA_finish,                             /* finish */
+#if 0/* FIXME !!! */
+	RSA_FLAG_GEN_KEY | RSA_FLAG_SIGN_VER,          /* flags */
+#else
+	RSA_FLAG_SIGN_VER,          /* flags */
+#endif
+	NULL,                                          /* app_data */
+	pkcs11_RSA_sign,                               /* rsa_sign */
+	pkcs11_RSA_verify,                             /* rsa_verify */
+	pkcs11_RSA_generate_key                       /* rsa_generate_key */ 
+};
+
+RSA_METHOD *PKCS11_RSA(void)
+{
+	return(&pkcs11_rsa);
+}
+#endif
+
+extern const char *RAND_version;
+
+static RAND_METHOD pkcs11_random =
+{
+	/* "PKCS11 RAND method", */
+	pkcs11_rand_seed,
+	pkcs11_rand_bytes,
+	pkcs11_rand_cleanup,
+	pkcs11_rand_add,
+	pkcs11_rand_bytes,
+	pkcs11_rand_status
+};
+
+
+RAND_METHOD *PKCS11_RAND(void)
+{
+	return(&pkcs11_random);
+}
+
+static CK_FUNCTION_LIST_PTR pFunctionList = NULL;
+
+/* These are the static string constants for the DSO file name and the function
+ * symbol names to bind to. 
+ */
+static unsigned char PKCS11_KEY_ID[] = "PKCS#11";
+
+/* String used to detect a CC2000 Bull TrustWay crypto card */
+#define BULL_TRUSTWAY_LIBRARY_DESCRIPTION "Bull CC2000 PKCS#11 Library     "
+static CK_BBOOL Bull_TrustWay = FALSE;
+#undef BULL_CC2000 /* use Bull CC2000 hardware crypto */
+
+#undef BULL_CRYPTOBOX /* use Bull CryptoBox remote hardware crypto */
+
+#undef GPKCS11 /* use GPKCS11  software crypto */
+
+#define OPENCRYPTOKI /* use openCryptoki hardware crypto */
+
+#if defined(BULL_CC2000)
+static const char def_PKCS11_LIBNAME[] = "gpkcs11cc2000";
+#elif defined(BULL_CRYPTOBOX)
+static const char def_PKCS11_LIBNAME[] = "cryptobox_clnt";
+extern CK_RV C_InitializeRpc (CK_CHAR_PTR, CK_CHAR_PTR, CK_ULONG_PTR);
+#elif defined(GPKCS11) 
+static const char def_PKCS11_LIBNAME[] = "gpkcs11";
+#elif defined(OPENCRYPTOKI)
+static char *def_PKCS11_LIBNAME = sizeof(long) == 8 ?
+"/usr/lib64/pkcs11/PKCS11_API.so":
+"/usr/lib/pkcs11/PKCS11_API.so";
+#else
+static const char def_PKCS11_LIBNAME[] = "pkcs11";
+#endif
+static const char PKCS11_GET_FUNCTION_LIST[] = "C_GetFunctionList";
+
+/* Size of an SSL signature: MD5+SHA1. up to allow SHA512  */
+#define SSL_SIG_LENGTH	64
+#define KEY_STORE 1
+static CK_BBOOL true = TRUE;
+static CK_BBOOL false = FALSE;
+static CK_SLOT_ID SLOTID = 0XFFFFFFFF;
+
+#ifndef OPENSSL_NO_RSA
+/* Where in the CRYPTO_EX_DATA stack we stick our per-key contexts */
+static int rsaPubKey = -1;
+static int rsaPrivKey = -1;
+static int deletePubKeyOnFree = -1;
+static int deletePrivKeyOnFree = -1;
+#endif
+
+static int PKCS11_Initialized = 0;
+
+#ifdef PKCS11_DEBUG
+#define DBG_fprintf(args...) do { fprintf(stderr, args); fflush(stderr); } while (0)
+#else
+#define DBG_fprintf(args...)
+#endif
+
+void pkcs11_atfork_init(void)
+{
+	DBG_fprintf("pkcs11_atfork_init: called (pid %d)\n", getpid());
+	PKCS11_Initialized = 0;
+}
+
+#define pkcs11_die(func, reason, rv) \
+{ \
+	char tmpbuf[20]; \
+	PKCS11err(func, reason); \
+	sprintf(tmpbuf, "%lx", rv); \
+	ERR_add_error_data(2, "PKCS11 CK_RV=0X", tmpbuf); \
+}
+
+struct token_session *pkcs11_getSession(void)
+{
+	CK_RV rv;
+	struct token_session *wrapper = OPENSSL_malloc(sizeof (struct token_session));
+
+	if (!wrapper) {
+		PKCS11err(PKCS11_F_GETSESSION, PKCS11_R_MALLOC_FAILURE);
+		return NULL;
+	}
+
+	wrapper->token = pkcs11_token_list;
+
+	if (!PKCS11_Initialized) {
+		rv = pFunctionList->C_Initialize(NULL);
+		if (rv != CKR_OK && rv != CKR_CRYPTOKI_ALREADY_INITIALIZED) {
+			pkcs11_die(PKCS11_F_GETSESSION, PKCS11_R_INITIALIZE, rv);
+			return NULL;
+		}
+		PKCS11_Initialized = 1;
+	}
+
+	rv = pFunctionList->C_OpenSession(wrapper->token->slot,
+			CKF_SERIAL_SESSION | CKF_RW_SESSION,
+			NULL_PTR,
+			NULL_PTR,
+			&wrapper->session);
+	if (rv != CKR_OK) {
+		pkcs11_die(PKCS11_F_GETSESSION, PKCS11_R_OPENSESSION, rv);
+		return NULL;
+	}
+
+	return wrapper;
+}
+
+char *alg_to_string(int alg_type)
+{
+	switch (alg_type) {
+		case alg_des:
+			return "des";
+		case alg_tdes:
+			return "tdes";
+		case alg_aes:
+			return "aes";
+		case alg_rsa:
+			return "rsa";
+		case alg_sha:
+			return "sha";
+		case alg_md5:
+			return "md5";
+		case alg_ripemd:
+			return "ripemd";
+		default:
+			return "invalid algorithm";
+	}
+}
+
+/* This internal function is used by ENGINE_pkcs11() and possibly by the
+ * "dynamic" ENGINE support too */
+static int bind_pkcs11(ENGINE *e)
+{
+	if(!ENGINE_set_id(e, engine_pkcs11_id) ||
+			!ENGINE_set_name(e, engine_pkcs11_name) ||
+#if 0
+#ifndef OPENSSL_NO_RSA
+			!ENGINE_set_RSA(e, &pkcs11_rsa) ||
+			!ENGINE_set_load_privkey_function(e, pkcs11_load_privkey) ||
+			!ENGINE_set_load_pubkey_function(e, pkcs11_load_pubkey) ||
+#endif
+#endif
+			!ENGINE_set_RAND(e, &pkcs11_random) ||
+			!ENGINE_set_init_function(e, pkcs11_init) ||
+			!ENGINE_set_ciphers(e, pkcs11_engine_ciphers) ||
+			!ENGINE_set_digests(e, pkcs11_engine_digests) ||
+			!ENGINE_set_destroy_function(e, pkcs11_destroy) ||
+			!ENGINE_set_finish_function(e, pkcs11_finish) ||
+			!ENGINE_set_ctrl_function(e, pkcs11_ctrl) ||
+			!ENGINE_set_cmd_defns(e, pkcs11_cmd_defns))
+		return 0;
+
+	/* Ensure the pkcs11 error handling is set up */
+	ERR_load_pkcs11_strings();
+
+	return 1;
+}
+
+#ifdef ENGINE_DYNAMIC_SUPPORT
+static int bind_helper(ENGINE *e, const char *id)
+{
+	if(id && (strcmp(id, engine_pkcs11_id) != 0))
+		return 0;
+	if(!bind_pkcs11(e))
+		return 0;
+	return 1;
+}
+IMPLEMENT_DYNAMIC_CHECK_FN()
+IMPLEMENT_DYNAMIC_BIND_FN(bind_helper)
+#else
+static ENGINE *engine_pkcs11(void)
+{
+	ENGINE *ret = ENGINE_new();
+	if(!ret)
+		return NULL;
+	if(!bind_pkcs11(ret))
+	{
+		ENGINE_free(ret);
+		return NULL;
+	}
+
+	pre_init_pkcs11(ret);
+
+	return ret;
+}
+
+void ENGINE_load_pkcs11(void)
+{
+	ENGINE *e_pkcs11 = engine_pkcs11();
+	if(!e_pkcs11) return;
+	ENGINE_add(e_pkcs11);
+	ENGINE_free(e_pkcs11);
+	ERR_clear_error();
+}
+#endif
+
+#define PKCS11_MAX_ALGS 20
+
+static int
+get_pkcs11_ciphers(const int **retnids)
+{
+	static int nids[PKCS11_MAX_ALGS];
+	int i, count = 0;
+
+	memset(nids, 0, sizeof(nids));
+	*retnids = NULL;
+
+	for (i=0; i<NUM_NID; i++) {
+		if (pkcs11_implemented_ciphers[i])
+			nids[count++] = i;
+	}
+
+	if (count)
+		*retnids = nids;
+	return count;
+}
+
+static int
+get_pkcs11_digests(const int **retnids)
+{
+	static int nids[PKCS11_MAX_ALGS];
+	int i, count = 0;
+
+	memset(nids, 0, sizeof(nids));
+	*retnids = NULL;
+
+	for (i=0; i<NUM_NID; i++) {
+		if (pkcs11_implemented_digests[i])
+			nids[count++] = i;
+	}
+
+	if (count)
+		*retnids = nids;
+	return count;
+}
+
+/*
+ * ENGINE calls this to find out how to deal with
+ * a particular NID in the ENGINE.
+ */
+static int pkcs11_engine_ciphers(ENGINE * e, const EVP_CIPHER ** cipher,
+		const int **nids, int nid)
+{
+	if (!cipher)
+		return get_pkcs11_ciphers(nids);
+
+	/* If the algorithm requested was not added to the list at
+	 * engine init time, don't return a reference to that structure.
+	 */
+	if (pkcs11_implemented_ciphers[nid]) {
+		switch (nid) {
+			case NID_aes_128_ecb:
+				*cipher = &pkcs11_aes_128_ecb;
+				break;
+			case NID_aes_192_ecb:
+				*cipher = &pkcs11_aes_192_ecb;
+				break;
+			case NID_aes_256_ecb:
+				*cipher = &pkcs11_aes_256_ecb;
+				break;
+			case NID_aes_128_cbc:
+				*cipher = &pkcs11_aes_128_cbc;
+				break;
+			case NID_aes_192_cbc:
+				*cipher = &pkcs11_aes_192_cbc;
+				break;
+			case NID_aes_256_cbc:
+				*cipher = &pkcs11_aes_256_cbc;
+				break;
+			case NID_des_ecb:
+				*cipher = &pkcs11_des_ecb;
+				break;
+			case NID_des_cbc:
+				*cipher = &pkcs11_des_cbc;
+				break;
+			case NID_des_ede3_ecb:
+				*cipher = &pkcs11_tdes_ecb;
+				break;
+			case NID_des_ede3_cbc:
+				*cipher = &pkcs11_tdes_cbc;
+				break;
+			default:
+				*cipher = NULL;
+				break;
+		}
+	}
+	return (*cipher != NULL);
+}
+
+static int pkcs11_engine_digests(ENGINE * e, const EVP_MD ** digest,
+		const int **nids, int nid)
+{
+
+	if (!digest)
+		return get_pkcs11_digests(nids);
+
+	if (pkcs11_implemented_digests[nid]) {
+		switch (nid) {
+			case NID_ripemd160:
+				*digest = &pkcs11_ripemd;
+				break;
+			case NID_md5:
+				*digest = &pkcs11_md5;
+				break;
+			case NID_sha1:
+				*digest = &pkcs11_sha1;
+				break;
+			default:
+				*digest = NULL;
+				break;
+		}
+	}
+	return (*digest != NULL);
+}
+
+/* This is a process-global DSO handle used for loading and unloading
+ * the PKCS#11 library. NB: This is only set (or unset) during an
+ * init() or finish() call (reference counts permitting) and they're
+ * operating with global locks, so this should be thread-safe
+ * implicitly. */
+static DSO *pkcs11_dso = NULL;
+
+/* These are the static string constants for the DSO file name and the function
+ * symbol names to bind to. 
+ */
+static const char *PKCS11_LIBNAME = NULL;
+static const char *get_PKCS11_LIBNAME(void)
+{
+	if(PKCS11_LIBNAME)
+		return PKCS11_LIBNAME;
+	return def_PKCS11_LIBNAME;
+}
+static void free_PKCS11_LIBNAME(void)
+{
+	if(PKCS11_LIBNAME)
+		OPENSSL_free((void*)PKCS11_LIBNAME);
+	PKCS11_LIBNAME = NULL;
+}
+static long set_PKCS11_LIBNAME(const char *name)
+{
+	free_PKCS11_LIBNAME();
+	return ((PKCS11_LIBNAME = BUF_strdup(name)) != NULL ? 1 : 0);
+}
+
+int add_hw_token(struct _token *new_tok, CK_MECHANISM_TYPE mech, struct _token **list_head,
+		short *enabled, struct _token **next_ptr)
+{
+	CK_RV rv;
+	CK_MECHANISM_INFO mech_info;
+
+	rv = pFunctionList->C_GetMechanismInfo(new_tok->slot, mech, &mech_info);
+	if (rv != CKR_OK) {
+		pkcs11_die(PKCS11_F_ADDTOKEN, PKCS11_R_GETMECHANISMINFO, rv);
+	}
+
+	/* return 0 if not HW enabled */
+	if ((mech_info.flags & CKF_HW) == 0)
+		return 0;
+
+	if (!*enabled) {
+		*enabled = 1;
+		*next_ptr = *list_head;
+		*list_head = new_tok;
+	}
+
+	/* return 1 if HW enabled */
+	return 1;
+}
+
+/* Add new NID's based on this slot's token */
+void pkcs11_regToken(ENGINE *e, CK_SLOT_ID slot_id)
+{
+	CK_RV rv;
+	CK_ULONG mech_cnt;
+	CK_MECHANISM_TYPE_PTR mech_list;
+	int i;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	rv = pFunctionList->C_GetMechanismList(slot_id, NULL_PTR, &mech_cnt);
+	if (rv != CKR_OK) {
+		pkcs11_die(PKCS11_F_ADDTOKEN, PKCS11_R_GETMECHANISMLIST, rv);
+		goto err;
+	}
+
+	/* Bounds check mech_cnt ? */
+	mech_list = (CK_MECHANISM_TYPE_PTR) OPENSSL_malloc(mech_cnt * sizeof(CK_MECHANISM_TYPE));
+	if (mech_list == NULL) {
+		pkcs11_die(PKCS11_F_ADDTOKEN, PKCS11_R_MALLOC_FAILURE, rv);
+		goto err;
+	}
+
+	rv = pFunctionList->C_GetMechanismList(slot_id, mech_list, &mech_cnt);
+	if (rv != CKR_OK) {
+		pkcs11_die(PKCS11_F_ADDTOKEN, PKCS11_R_GETMECHANISMLIST, rv);
+		goto err_free;
+	}
+
+	/* Check which mechanisms are performed in hardware */
+	for( i = 0; i < mech_cnt; i++ ) {
+		switch (mech_list[i]) {
+			case CKM_RSA_PKCS_KEY_PAIR_GEN:
+			case CKM_RSA_PKCS:
+			case CKM_RSA_9796:
+			case CKM_RSA_X_509:
+			case CKM_RSA_PKCS_OAEP:
+			case CKM_RSA_X9_31:
+			case CKM_RSA_X9_31_KEY_PAIR_GEN:
+			case CKM_MD5_RSA_PKCS:
+#ifndef OPENSSL_NO_RSA
+				DBG_fprintf("%s: registering RSA\n", __FUNCTION__);
+				ENGINE_set_RSA(e, &pkcs11_rsa);
+				ENGINE_set_load_privkey_function(e, pkcs11_load_privkey);
+				ENGINE_set_load_pubkey_function(e, pkcs11_load_pubkey);
+#endif
+				break; 
+			case CKM_DH_PKCS_KEY_PAIR_GEN:
+			case CKM_DH_PKCS_DERIVE:
+			case CKM_X9_42_DH_KEY_PAIR_GEN:
+			case CKM_X9_42_DH_DERIVE:
+			case CKM_X9_42_DH_HYBRID_DERIVE:
+			case CKM_DH_PKCS_PARAMETER_GEN:
+			case CKM_X9_42_DH_PARAMETER_GEN:
+				break;
+			case CKM_DES_ECB:
+				pkcs11_implemented_ciphers[NID_des_ecb] = 1;
+				num_cipher_nids++;
+				break;
+			case CKM_DES_CBC:
+			case CKM_DES_CBC_PAD:
+				pkcs11_implemented_ciphers[NID_des_cbc] = 1;
+				num_cipher_nids++;
+				break;
+			case CKM_DES_KEY_GEN:
+			case CKM_DES_MAC:
+			case CKM_DES_MAC_GENERAL:
+				break; 
+			case CKM_DES3_ECB:
+				pkcs11_implemented_ciphers[NID_des_ede3_ecb] = 1;
+				num_cipher_nids++;
+				break;
+			case CKM_DES3_CBC:
+			case CKM_DES3_CBC_PAD:
+				pkcs11_implemented_ciphers[NID_des_ede3_cbc] = 1;
+				num_cipher_nids++;
+				break;
+			case CKM_DES3_KEY_GEN:
+			case CKM_DES3_MAC:
+			case CKM_DES3_MAC_GENERAL:
+				break; 
+			case CKM_SHA_1:
+				pkcs11_implemented_digests[NID_sha1] = 1;
+				num_digest_nids++;
+				break;
+			case CKM_SHA_1_HMAC:
+			case CKM_SHA_1_HMAC_GENERAL:
+				pkcs11_implemented_digests[NID_hmacWithSHA1] = 1;
+				num_digest_nids++;
+				break;
+			case CKM_PBA_SHA1_WITH_SHA1_HMAC:
+			case CKM_SHA1_KEY_DERIVATION:
+			case CKM_SHA1_RSA_PKCS:
+				pkcs11_implemented_digests[NID_sha1WithRSAEncryption] = 1;
+				num_digest_nids++;
+				break; 
+				
+			case CKM_SHA224:
+				pkcs11_implemented_digests[NID_sha224] = 1;
+				num_digest_nids++;
+				break;
+			case CKM_SHA224_KEY_DERIVATION:
+			case CKM_SHA224_RSA_PKCS:
+				pkcs11_implemented_digests[NID_sha224WithRSAEncryption] = 1;
+				num_digest_nids++;
+				break; 
+				
+				
+			case CKM_SHA256:
+				pkcs11_implemented_digests[NID_sha256] = 1;
+				num_digest_nids++;
+				break;
+			case CKM_SHA256_KEY_DERIVATION:
+			case CKM_SHA256_RSA_PKCS:
+				pkcs11_implemented_digests[NID_sha256WithRSAEncryption] = 1;
+				num_digest_nids++;
+				break; 
+				
+			case CKM_SHA384:
+				pkcs11_implemented_digests[NID_sha384] = 1;
+				num_digest_nids++;
+				break;
+			case CKM_SHA384_KEY_DERIVATION:
+			case CKM_SHA384_RSA_PKCS:
+				pkcs11_implemented_digests[NID_sha384WithRSAEncryption] = 1;
+				num_digest_nids++;
+				break; 
+			case CKM_SHA512:
+				pkcs11_implemented_digests[NID_sha512] = 1;
+				num_digest_nids++;
+				break;
+			case CKM_SHA512_KEY_DERIVATION:
+			case CKM_SHA512_RSA_PKCS:
+				pkcs11_implemented_digests[NID_sha512WithRSAEncryption] = 1;
+				num_digest_nids++;
+				break; 
+				
+			case CKM_AES_ECB:
+				pkcs11_implemented_ciphers[NID_aes_128_ecb] = 1;
+				pkcs11_implemented_ciphers[NID_aes_192_ecb] = 1;
+				pkcs11_implemented_ciphers[NID_aes_256_ecb] = 1;
+				num_cipher_nids += 3;
+				break;
+			case CKM_AES_KEY_GEN:
+				break;
+			case CKM_AES_CBC_PAD:
+			case CKM_AES_CBC:
+				pkcs11_implemented_ciphers[NID_aes_128_cbc] = 1;
+				pkcs11_implemented_ciphers[NID_aes_192_cbc] = 1;
+				pkcs11_implemented_ciphers[NID_aes_256_cbc] = 1;
+				num_cipher_nids += 3;
+				break;
+			case CKM_AES_MAC:
+			case CKM_AES_MAC_GENERAL:
+				break; 
+			case CKM_MD5:
+				pkcs11_implemented_digests[NID_md5] = 1;
+				num_digest_nids++;
+				break;
+			case CKM_MD5_HMAC:
+			case CKM_MD5_HMAC_GENERAL:
+			case CKM_SSL3_PRE_MASTER_KEY_GEN:
+			case CKM_SSL3_MASTER_KEY_DERIVE:
+			case CKM_SSL3_KEY_AND_MAC_DERIVE:
+			case CKM_SSL3_MD5_MAC:
+			case CKM_SSL3_SHA1_MAC:
+				break;
+			case CKM_RIPEMD160:
+				pkcs11_implemented_digests[NID_ripemd160] = 1;
+				num_digest_nids++;
+				break;
+			case CKM_RIPEMD160_HMAC:
+			case CKM_RIPEMD160_HMAC_GENERAL:
+				break;
+			default:
+#if 0
+				printf("The token in slot %lx has reported that it can perform some\n"
+						"mechanism not available to accelerate in openssl.\n", slot_id);
+#endif
+				break;
+		}
+	}
+
+err_free:
+	OPENSSL_free(mech_list);
+err:
+	return;
+}
+
+/* Add a new token struct to the list 
+ * This is called during the bind_pkcs11, in other words after openSSL has
+ * decided to use us for some operation.
+ */
+void pkcs11_addToken(CK_SLOT_ID slot_id)
+{
+	struct _token *new_tok = (struct _token *) OPENSSL_malloc(sizeof(struct _token));
+
+	if (new_tok == NULL) {
+		PKCS11err(PKCS11_F_ADDTOKEN, PKCS11_R_MALLOC_FAILURE);
+		return;
+	}
+
+	memset(new_tok, 0, sizeof(struct _token));
+	new_tok->slot = slot_id;
+
+	new_tok->token_next = pkcs11_token_list;
+	pkcs11_token_list = new_tok;
+}
+
+/*
+ * pre_init_pkcs11:  this is called at openSSL startup.  Here is where we
+ * try to convince openSSL to use us.  If it decides not to, there is no
+ * guarantee that we will ever be asked to clean up.  So everything we
+ * do must be self-contained.
+ */
+static int pre_init_pkcs11(ENGINE *e)
+{
+	CK_C_GetFunctionList p;
+	CK_RV rv = CKR_OK;
+	CK_INFO Info;
+	CK_SLOT_ID_PTR pSlotList;
+	CK_ULONG ulSlotCount;
+	CK_SLOT_INFO slotInfo;
+	int i;
+
+	if(pkcs11_dso)
+	{
+		PKCS11err(PKCS11_F_PREINIT, PKCS11_R_ALREADY_LOADED);
+		goto err;
+	}
+
+	/* Attempt to load PKCS#11 library */
+	pkcs11_dso = DSO_load(NULL, get_PKCS11_LIBNAME(), NULL, 0);
+
+	if(pkcs11_dso == NULL)
+	{
+		PKCS11err(PKCS11_F_PREINIT, PKCS11_R_DSO_FAILURE);
+		goto err;
+	}
+
+	/* get the C_GetFunctionList function from the loaded library */
+	p = (CK_C_GetFunctionList)DSO_bind_func(pkcs11_dso, PKCS11_GET_FUNCTION_LIST);
+	if ( !p )
+	{
+		PKCS11err(PKCS11_F_PREINIT, PKCS11_R_DSO_FAILURE);
+		goto err;
+	}
+
+	/* get the full function list from the loaded library */
+	rv = p(&pFunctionList);
+	if (rv != CKR_OK)
+	{
+		pkcs11_die(PKCS11_F_PREINIT, PKCS11_R_DSO_FAILURE, rv);
+		goto err;
+	}
+
+#ifdef BULL_CRYPTOBOX
+	/* the address of the CryptoBox is in /etc/CryptoBox */
+	rv = C_InitializeRpc (NULL, NULL, NULL);
+	if (rv != CKR_OK)
+		goto err;
+#endif
+
+	/* Initialize Cryptoki */
+	rv = pFunctionList->C_Initialize(NULL_PTR);
+	if ((rv != CKR_OK) && (rv != CKR_CRYPTOKI_ALREADY_INITIALIZED))
+	{
+		pkcs11_die(PKCS11_F_PREINIT, PKCS11_R_INITIALIZE, rv);
+		goto err;
+	}
+	rv = pFunctionList->C_GetInfo(&Info);
+	if (rv != CKR_OK) 
+	{
+		pkcs11_die(PKCS11_F_PREINIT, PKCS11_R_GETINFO, rv);
+		goto err;
+	}
+
+ 	if (strncmp((char *)Info.libraryDescription, BULL_TRUSTWAY_LIBRARY_DESCRIPTION, 32))
+	{
+		rv = pFunctionList->C_GetSlotList(TRUE, NULL_PTR, &ulSlotCount);
+		if ((rv != CKR_OK) || (ulSlotCount == 0)) 
+		{
+			pkcs11_die(PKCS11_F_PREINIT, PKCS11_R_GETSLOTLIST, rv);
+		}
+		else
+		{
+			pSlotList = (CK_SLOT_ID_PTR) OPENSSL_malloc(ulSlotCount * sizeof(CK_SLOT_ID));
+			if ( pSlotList != NULL)
+			{
+				rv = pFunctionList->C_GetSlotList(TRUE, pSlotList, &ulSlotCount);
+				if (rv != CKR_OK) 
+				{
+					pkcs11_die(PKCS11_F_PREINIT, PKCS11_R_GETSLOTLIST, rv);
+					OPENSSL_free(pSlotList);
+					goto err;
+				}
+
+				/* Check each slot to see if there's a hardware token present.
+				*/
+				for (i = 0; i < ulSlotCount; i++)
+				{
+					rv = pFunctionList->C_GetSlotInfo(pSlotList[i], &slotInfo);
+					if (rv != CKR_OK)
+					{
+						pkcs11_die(PKCS11_F_PREINIT, PKCS11_R_GETSLOTINFO, rv);
+						OPENSSL_free(pSlotList);
+						goto err;
+					}
+
+					pkcs11_regToken(e, pSlotList[i]);
+				}
+				OPENSSL_free(pSlotList);
+			}
+		}
+	}
+	else
+	{
+		/* Bull Trustway CC2000 crypto hardware detected */
+		Bull_TrustWay = TRUE;
+		SLOTID = 0xFFFFFFFF;
+	}
+
+	/* Finish with Cryptoki:  We will restart if openSSL calls one of our
+	 * functions */
+	pFunctionList->C_Finalize(NULL);
+	DSO_free(pkcs11_dso);
+	pkcs11_dso = NULL;
+
+	return 1;
+
+err:
+	if(pkcs11_dso)
+		DSO_free(pkcs11_dso);
+	pkcs11_dso = NULL;
+	return 0;
+}
+
+/* initialization function */
+/* This is called when openSSL has decided to use us, and warns us to
+ * initialize.  pkcs11_finish will be called when all is done.  */
+static int pkcs11_init(ENGINE *e)
+{
+	CK_C_GetFunctionList p;
+	CK_RV rv = CKR_OK;
+	CK_INFO Info;
+	CK_SLOT_ID_PTR pSlotList;
+	CK_ULONG ulSlotCount;
+	CK_SLOT_INFO slotInfo;
+	int i;
+
+	if(pkcs11_dso)
+	{
+		PKCS11err(PKCS11_F_INIT, PKCS11_R_ALREADY_LOADED);
+		goto err;
+	}
+
+	/* Attempt to load PKCS#11 library */
+	pkcs11_dso = DSO_load(NULL, get_PKCS11_LIBNAME(), NULL, 0);
+
+	if(pkcs11_dso == NULL)
+	{
+		PKCS11err(PKCS11_F_INIT, PKCS11_R_DSO_FAILURE);
+		goto err;
+	}
+
+	/* get the C_GetFunctionList function from the loaded library */
+	p = (CK_C_GetFunctionList)DSO_bind_func(pkcs11_dso, PKCS11_GET_FUNCTION_LIST);
+	if ( !p )
+	{
+		PKCS11err(PKCS11_F_INIT, PKCS11_R_DSO_FAILURE);
+		goto err;
+	}
+
+	/* get the full function list from the loaded library */
+	rv = p(&pFunctionList);
+	if (rv != CKR_OK)
+	{
+		pkcs11_die(PKCS11_F_INIT, PKCS11_R_DSO_FAILURE, rv);
+		goto err;
+	}
+
+#ifdef BULL_CRYPTOBOX
+	/* the address of the CryptoBox is in /etc/CryptoBox */
+	rv = C_InitializeRpc (NULL, NULL, NULL);
+	if (rv != CKR_OK)
+		goto err;
+#endif
+
+	rv = pFunctionList->C_Initialize(NULL_PTR);
+	if ((rv != CKR_OK) && (rv != CKR_CRYPTOKI_ALREADY_INITIALIZED))
+	{
+		pkcs11_die(PKCS11_F_INIT, PKCS11_R_INITIALIZE, rv);
+		goto err;
+	}
+	rv = pFunctionList->C_GetInfo(&Info);
+	if (rv != CKR_OK) 
+	{
+		pkcs11_die(PKCS11_F_INIT, PKCS11_R_GETINFO, rv);
+		goto err;
+	}
+
+	if (strncmp((char *)Info.libraryDescription, BULL_TRUSTWAY_LIBRARY_DESCRIPTION, 32))
+	{
+		rv = pFunctionList->C_GetSlotList(TRUE, NULL_PTR, &ulSlotCount);
+		if ((rv != CKR_OK) || (ulSlotCount == 0)) 
+		{
+			pkcs11_die(PKCS11_F_INIT, PKCS11_R_GETSLOTLIST, rv);
+		}
+		else
+		{
+			pSlotList = (CK_SLOT_ID_PTR) OPENSSL_malloc(ulSlotCount * sizeof(CK_SLOT_ID));
+			if ( pSlotList != NULL)
+			{
+				rv = pFunctionList->C_GetSlotList(TRUE, pSlotList, &ulSlotCount);
+				if (rv != CKR_OK) 
+				{
+					pkcs11_die(PKCS11_F_INIT, PKCS11_R_GETSLOTLIST, rv);
+					OPENSSL_free(pSlotList);
+					goto err;
+				}
+
+				/* Check each slot to see if there's a hardware token present.
+				*/
+				for (i = 0; i < ulSlotCount; i++)
+				{
+					rv = pFunctionList->C_GetSlotInfo(pSlotList[i], &slotInfo);
+					if (rv != CKR_OK)
+					{
+						pkcs11_die(PKCS11_F_INIT, PKCS11_R_GETSLOTINFO, rv);
+						OPENSSL_free(pSlotList);
+						goto err;
+					}
+
+					pkcs11_addToken(pSlotList[i]);
+				}
+				OPENSSL_free(pSlotList);
+			}
+		}
+	}
+	else
+	{
+		/* Bull Trustway CC2000 crypto hardware detected */
+		Bull_TrustWay = TRUE;
+		SLOTID = 0xFFFFFFFF;
+	}
+
+#ifndef OPENSSL_NO_RSA
+	/* Everything's fine. */
+	if (rsaPubKey == -1)
+		rsaPubKey = RSA_get_ex_new_index(0, NULL, NULL, NULL, NULL);
+	if (rsaPrivKey == -1)
+		rsaPrivKey = RSA_get_ex_new_index(0, NULL, NULL, NULL, NULL);
+	if (deletePubKeyOnFree == -1)
+		deletePubKeyOnFree = RSA_get_ex_new_index(0, NULL, NULL, NULL, NULL);
+	if (deletePrivKeyOnFree == -1)
+		deletePrivKeyOnFree = RSA_get_ex_new_index(0, NULL, NULL, NULL, NULL);
+#endif
+
+	if (pkcs11_token_list == NULL)
+		PKCS11err(PKCS11_F_INIT, PKCS11_R_NOTOKENS);
+
+	PKCS11_Initialized = 1;
+
+	/* TODO:  This should only be done on linux systems */
+	pthread_atfork(NULL, NULL, (void(*)())pkcs11_atfork_init);
+
+	return 1;
+
+err:
+	if(pkcs11_dso)
+		DSO_free(pkcs11_dso);
+	pkcs11_dso = NULL;
+	return 0;
+}
+
+/* Destructor (complements the "ENGINE_pkcs11()" constructor) */
+/* XXX HUH?  Can we just DSO_load once, then??? */
+static int pkcs11_destroy(ENGINE *e)
+{
+	fprintf(stderr, "%s: called\n", __FUNCTION__);
+	fflush(stderr);
+	free_PKCS11_LIBNAME();
+	ERR_unload_pkcs11_strings();
+	return 1;
+}
+
+/* termination function */
+static int pkcs11_finish(ENGINE *e)
+{
+	struct _token *tmp;
+
+	if(pkcs11_dso == NULL)
+	{
+		PKCS11err(PKCS11_F_FINISH, PKCS11_R_NOT_LOADED);
+		goto err;
+	}
+	assert(pFunctionList != NULL);
+
+	while (pkcs11_token_list) {
+		tmp = pkcs11_token_list->token_next;
+		OPENSSL_free(pkcs11_token_list);
+		pkcs11_token_list = tmp;
+	}
+
+	pFunctionList->C_Finalize(NULL);
+
+	if(!DSO_free(pkcs11_dso))
+	{	PKCS11err(PKCS11_F_FINISH, PKCS11_R_DSO_FAILURE);
+		goto err;
+	}
+	pkcs11_dso = NULL;
+	pFunctionList = NULL;
+
+	return 1;
+
+err:
+	pkcs11_dso = NULL;
+	pFunctionList = NULL;
+	return 0;
+}
+
+static int pkcs11_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)())
+{
+	int initialized = ((pkcs11_dso == NULL) ? 0 : 1);
+	switch(cmd)
+	{
+		case PKCS11_CMD_SO_PATH:
+			if(p == NULL)
+			{
+				PKCS11err(PKCS11_F_CTRL, ERR_R_PASSED_NULL_PARAMETER);
+				return 0;
+			}
+			if(initialized)
+			{
+				PKCS11err(PKCS11_F_CTRL, PKCS11_R_ALREADY_LOADED);
+				return 0;
+			}
+			return set_PKCS11_LIBNAME((const char*)p);
+		default:
+			break;
+	}
+	PKCS11err(PKCS11_F_CTRL,PKCS11_R_CTRL_COMMAND_NOT_IMPLEMENTED);
+	return 0;
+}
+
+#ifndef OPENSSL_NO_RSA
+CK_OBJECT_HANDLE pkcs11_FindOrCreateKey(CK_SESSION_HANDLE h, RSA* rsa, CK_OBJECT_CLASS oKey, CK_BBOOL fKeyCreate)
+{
+	CK_RV rv;
+	CK_OBJECT_HANDLE hKey = CK_INVALID_HANDLE;
+	int ret=0;
+	CK_ULONG Matches;
+	CK_KEY_TYPE kType = CKK_RSA;
+	CK_ULONG ulKeyAttributeCount;
+	CK_ATTRIBUTE  pubKeyTemplate[] =
+	{
+		{CKA_CLASS, &oKey, sizeof(CK_OBJECT_CLASS)},
+		{CKA_KEY_TYPE, &kType, sizeof(CK_KEY_TYPE)},
+		{CKA_MODULUS, (void *)NULL, 0},
+		{CKA_PUBLIC_EXPONENT, (void *)NULL, 0},
+	};
+	CK_ATTRIBUTE  privKeyTemplate[] =
+	{
+		{CKA_CLASS, &oKey, sizeof(CK_OBJECT_CLASS)},
+		{CKA_KEY_TYPE, &kType, sizeof(CK_KEY_TYPE)},
+		{CKA_MODULUS, (void *)NULL, 0},
+		{CKA_PUBLIC_EXPONENT, (void *)NULL, 0},
+		{CKA_PRIVATE_EXPONENT, (void *)NULL, 0},
+		{CKA_PRIME_1, (void *)NULL, 0},
+		{CKA_PRIME_2, (void *)NULL, 0},
+		{CKA_EXPONENT_1, (void *)NULL, 0},
+		{CKA_EXPONENT_2, (void *)NULL, 0},
+		{CKA_COEFFICIENT, (void *)NULL, 0}
+	};
+	int  deletePubKey;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	if (oKey == CKO_PUBLIC_KEY) {
+		DBG_fprintf("looking up a public key\n");
+		pubKeyTemplate[2].ulValueLen = BN_num_bytes(rsa->n);
+		pubKeyTemplate[2].pValue = (CK_VOID_PTR)OPENSSL_malloc((size_t)pubKeyTemplate[2].ulValueLen);
+		ret = BN_bn2bin(rsa->n, pubKeyTemplate[2].pValue);
+
+		pubKeyTemplate[3].ulValueLen = BN_num_bytes(rsa->e);
+		pubKeyTemplate[3].pValue = (CK_VOID_PTR)OPENSSL_malloc((size_t)pubKeyTemplate[3].ulValueLen);
+		ret = BN_bn2bin(rsa->e, pubKeyTemplate[3].pValue);
+
+		ulKeyAttributeCount = 4;
+		rv = pFunctionList->C_FindObjectsInit(h, pubKeyTemplate, ulKeyAttributeCount);
+	} else {
+		DBG_fprintf("looking up a private key\n");
+		privKeyTemplate[2].ulValueLen = BN_num_bytes(rsa->n);
+		privKeyTemplate[2].pValue = (CK_VOID_PTR)OPENSSL_malloc((size_t)privKeyTemplate[2].ulValueLen);
+		ret = BN_bn2bin(rsa->n, privKeyTemplate[2].pValue);
+
+		privKeyTemplate[3].ulValueLen = BN_num_bytes(rsa->e);
+		privKeyTemplate[3].pValue = (CK_VOID_PTR)OPENSSL_malloc((size_t)privKeyTemplate[3].ulValueLen);
+		ret = BN_bn2bin(rsa->e, privKeyTemplate[3].pValue);
+
+		privKeyTemplate[4].ulValueLen = BN_num_bytes(rsa->d);
+		privKeyTemplate[4].pValue = (CK_VOID_PTR)OPENSSL_malloc((size_t)privKeyTemplate[4].ulValueLen);
+		ret = BN_bn2bin(rsa->d, privKeyTemplate[4].pValue);
+
+		privKeyTemplate[5].ulValueLen = BN_num_bytes(rsa->p);
+		privKeyTemplate[5].pValue = (CK_VOID_PTR)OPENSSL_malloc((size_t)privKeyTemplate[5].ulValueLen);
+		ret = BN_bn2bin(rsa->p, privKeyTemplate[5].pValue);
+
+		privKeyTemplate[6].ulValueLen = BN_num_bytes(rsa->q);
+		privKeyTemplate[6].pValue = (CK_VOID_PTR)OPENSSL_malloc((size_t)privKeyTemplate[6].ulValueLen);
+		ret = BN_bn2bin(rsa->q, privKeyTemplate[6].pValue);
+
+		privKeyTemplate[7].ulValueLen = BN_num_bytes(rsa->dmp1);
+		privKeyTemplate[7].pValue = (CK_VOID_PTR)OPENSSL_malloc((size_t)privKeyTemplate[7].ulValueLen);
+		ret = BN_bn2bin(rsa->dmp1, privKeyTemplate[7].pValue);
+
+		privKeyTemplate[8].ulValueLen = BN_num_bytes(rsa->dmq1);
+		privKeyTemplate[8].pValue = (CK_VOID_PTR)OPENSSL_malloc((size_t)privKeyTemplate[8].ulValueLen);
+		ret = BN_bn2bin(rsa->dmq1, privKeyTemplate[8].pValue);
+
+		privKeyTemplate[9].ulValueLen = BN_num_bytes(rsa->iqmp);
+		privKeyTemplate[9].pValue = (CK_VOID_PTR)OPENSSL_malloc((size_t)privKeyTemplate[9].ulValueLen);
+		ret = BN_bn2bin(rsa->iqmp, privKeyTemplate[9].pValue);
+
+		ulKeyAttributeCount = 10;
+		rv = pFunctionList->C_FindObjectsInit(h, privKeyTemplate, ulKeyAttributeCount);
+	}
+
+	if (rv != CKR_OK)
+	{
+		pkcs11_die(PKCS11_F_FINDORCREATEKEY, PKCS11_R_FINDOBJECTSINIT, rv);
+		goto err;
+	}
+	rv = pFunctionList->C_FindObjects(h, &hKey, 1, &Matches);
+	if (rv != CKR_OK)
+	{
+		pkcs11_die(PKCS11_F_FINDORCREATEKEY, PKCS11_R_FINDOBJECTS, rv);
+		goto err;
+	}
+	rv = pFunctionList->C_FindObjectsFinal(h);
+	if (rv != CKR_OK)
+	{
+		pkcs11_die(PKCS11_F_FINDORCREATEKEY, PKCS11_R_FINDOBJECTSFINAL, rv);
+		goto err;
+	}
+	/* Assume there should be no more than one match */
+	if (Matches == 0)
+	{
+		DBG_fprintf("matches was 0, creating this key\n");
+		if (fKeyCreate) {
+			if (oKey == CKO_PUBLIC_KEY)
+				rv = pFunctionList->C_CreateObject(h, pubKeyTemplate, ulKeyAttributeCount, &hKey);
+			else
+				rv = pFunctionList->C_CreateObject(h, privKeyTemplate, ulKeyAttributeCount, &hKey);
+			if (rv != CKR_OK)
+			{
+				DBG_fprintf("error creating key object.\n");
+				pkcs11_die(PKCS11_F_FINDORCREATEKEY, PKCS11_R_CREATEOBJECT, rv);
+				goto err;
+			}
+			else
+			{
+				DBG_fprintf("key obj created\n");
+				deletePubKey = TRUE;
+				if (oKey == CKO_PUBLIC_KEY)
+					RSA_set_ex_data(rsa, deletePubKeyOnFree, (void *)deletePubKey);
+				else
+					RSA_set_ex_data(rsa, deletePrivKeyOnFree, (void *)deletePubKey);
+			}
+		}
+		else
+		{
+			PKCS11err(PKCS11_F_FINDORCREATEKEY, PKCS11_R_OBJECT_NOT_FOUND);
+			goto err;
+		}
+	}
+	if (oKey == CKO_PUBLIC_KEY)
+		RSA_set_ex_data(rsa, rsaPubKey, (char *)hKey);
+	if (oKey == CKO_PRIVATE_KEY)
+		RSA_set_ex_data(rsa, rsaPrivKey, (char *)hKey);
+
+err:
+	if (oKey == CKO_PUBLIC_KEY) {
+		if (pubKeyTemplate[2].pValue != NULL)
+		{
+			OPENSSL_free(pubKeyTemplate[2].pValue);
+			pubKeyTemplate[2].pValue = NULL;
+		}
+
+		if (pubKeyTemplate[3].pValue != NULL)
+		{
+			OPENSSL_free(pubKeyTemplate[3].pValue);
+			pubKeyTemplate[3].pValue = NULL;
+		}
+	} else {
+		if (privKeyTemplate[2].pValue != NULL)
+		{
+			OPENSSL_free(privKeyTemplate[2].pValue);
+			privKeyTemplate[2].pValue = NULL;
+		}
+
+		if (privKeyTemplate[3].pValue != NULL)
+		{
+			OPENSSL_free(privKeyTemplate[3].pValue);
+			privKeyTemplate[3].pValue = NULL;
+		}
+
+		if (privKeyTemplate[4].pValue != NULL)
+		{
+			OPENSSL_free(privKeyTemplate[4].pValue);
+			privKeyTemplate[4].pValue = NULL;
+		}
+	}
+
+	return hKey;
+
+}
+
+/*----------------------------------------------------------------*/
+/* pkcs11_RSA_public_encrypt */
+/* */
+/* This function implements RSA public encryption. 'from_len'
+   bytes taken from 'from' and encrypted and put into 'to'. 'to' needs
+   to be at least RSA_size(rsa) bytes long. The number of bytes
+   written into 'to' is returned. -1 is returned on an error. The
+   operation performed is to = from^rsa->e mod rsa->n. */
+/* for PKCS11, use C_EncryptInit + C_Encrypt */
+/*----------------------------------------------------------------*/
+static int pkcs11_RSA_public_encrypt(int flen,
+		const unsigned char *from,
+		unsigned char *to,
+		RSA *rsa,
+		int padding)
+{
+	CK_ULONG bytesEncrypted=0;
+	CK_RV rv;
+	CK_MECHANISM Mechanism_rsa = {CKM_RSA_PKCS, NULL, 0};
+	CK_MECHANISM *pMechanism = &Mechanism_rsa;
+	CK_OBJECT_HANDLE hPublicKey = CK_INVALID_HANDLE;
+	struct token_session *wrapper = NULL;
+	CK_SESSION_HANDLE session;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	if (padding != RSA_PKCS1_PADDING)
+	{
+		PKCS11err(PKCS11_F_RSA_PUB_ENC, PKCS11_R_UNKNOWN_PADDING_TYPE);
+		return -1;
+	}
+
+	wrapper = pkcs11_getSession();
+	if (!wrapper)
+		return 0;
+	session = wrapper->session;
+
+	hPublicKey = (CK_OBJECT_HANDLE)RSA_get_ex_data(rsa, rsaPubKey);
+	if (hPublicKey == CK_INVALID_HANDLE)
+		hPublicKey = pkcs11_FindOrCreateKey(session, rsa, CKO_PUBLIC_KEY, true);
+
+
+	if (hPublicKey != CK_INVALID_HANDLE)
+	{
+		rv = pFunctionList->C_EncryptInit(session, pMechanism, hPublicKey);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_PUB_ENC, PKCS11_R_ENCRYPTINIT, rv);
+			bytesEncrypted = -1;
+			goto out;
+		}
+
+		rv = pFunctionList->C_Encrypt(session, (unsigned char *)from,
+				flen, NULL_PTR, &bytesEncrypted);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_PUB_ENC, PKCS11_R_ENCRYPT, rv);
+			bytesEncrypted = -1;
+			goto out;
+		}
+
+		rv = pFunctionList->C_Encrypt(session, (unsigned char *)from,
+				flen, to, &bytesEncrypted);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_PUB_ENC, PKCS11_R_ENCRYPT, rv);
+			bytesEncrypted = -1;
+			goto out;
+		}
+	}
+
+
+out:
+	OPENSSL_free(wrapper);
+	return bytesEncrypted;
+}
+
+
+
+/*----------------------------------------------------------------*/
+/* pkcs11_RSA_private_encrypt */
+/* This function implements RSA private encryption.
+   That corresponds to a signature and only the RSA_PKCS1_PADDING
+   is supported.
+flen : bytes taken from 'from' and encrypted and put into 'to'.
+to : needs to be at least bytes long.
+ret : returns the number of bytes written into 'to' or -1 if an error.
+for PKCS11 use C_SignInit + C_Sign */
+/*----------------------------------------------------------------*/
+static int pkcs11_RSA_private_encrypt(int flen,
+		const unsigned char *from,
+		unsigned char *to,
+		RSA *rsa,
+		int padding)
+{
+	CK_ULONG ulSignatureLen=0;
+	CK_RV rv;
+	CK_MECHANISM Mechanism_rsa = {CKM_RSA_PKCS, NULL, 0};
+	CK_MECHANISM *pMechanism = &Mechanism_rsa;
+	CK_OBJECT_HANDLE hPrivateKey= CK_INVALID_HANDLE;
+	struct token_session *wrapper = NULL;
+	CK_SESSION_HANDLE session;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	if (padding != RSA_PKCS1_PADDING)
+	{
+		PKCS11err(PKCS11_F_RSA_PRIV_ENC, PKCS11_R_UNKNOWN_PADDING_TYPE);
+		return -1;
+	}
+
+	wrapper = pkcs11_getSession();
+	if (!wrapper)
+		return 0;
+	session = wrapper->session;
+
+	hPrivateKey = (CK_OBJECT_HANDLE)RSA_get_ex_data(rsa, rsaPrivKey);
+	if (hPrivateKey == CK_INVALID_HANDLE)
+		hPrivateKey = pkcs11_FindOrCreateKey(session, rsa, CKO_PRIVATE_KEY, true);
+
+	if (hPrivateKey != CK_INVALID_HANDLE)
+	{
+		rv = pFunctionList->C_SignInit(session, pMechanism, hPrivateKey);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_PRIV_ENC, PKCS11_R_SIGNINIT, rv);
+			ulSignatureLen = -1;
+			goto out;
+		}
+
+		rv = pFunctionList->C_Sign(session, (unsigned char *)from,
+				flen, NULL_PTR, &ulSignatureLen);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_PRIV_ENC, PKCS11_R_SIGN, rv);
+			ulSignatureLen = -1;
+			goto out;
+		}
+
+		rv = pFunctionList->C_Sign(session, (unsigned char *)from,
+				flen, to, &ulSignatureLen);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_PRIV_ENC, PKCS11_R_SIGN, rv);
+			ulSignatureLen = -1;
+			goto out;
+		}
+	}
+
+out:
+	OPENSSL_free(wrapper);
+	return ulSignatureLen;
+}
+
+
+
+/*----------------------------------------------------------------*/
+/* pkcs11_RSA_private_decrypt */
+/* */
+/*This function implements RSA private decryption.
+
+flen : bytes are taken from 'from' and decrypted.
+The decrypted data is put into 'to'. 
+ret : returns the number of bytes -1 if an error.
+The operation performed is to = from^rsa->d mod rsa->n.*/
+/* for PKCS11 use C_DecryptInit + C_Decrypt */
+/*----------------------------------------------------------------*/
+static int pkcs11_RSA_private_decrypt(int flen,
+		const unsigned char *from,
+		unsigned char *to,
+		RSA *rsa,
+		int padding)
+{
+	CK_ULONG bytesDecrypted = flen;
+	CK_RV rv;
+	CK_MECHANISM Mechanism_rsa = {CKM_RSA_PKCS, NULL, 0};
+	CK_MECHANISM *pMechanism = &Mechanism_rsa;
+	CK_OBJECT_HANDLE hPrivateKey;
+	struct token_session *wrapper = NULL;
+	CK_SESSION_HANDLE session;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	if (padding != RSA_PKCS1_PADDING)
+	{
+		PKCS11err(PKCS11_F_RSA_PRIV_DEC, PKCS11_R_UNKNOWN_PADDING_TYPE);
+		return -1;
+	}
+
+	wrapper = pkcs11_getSession();
+	if (!wrapper)
+		return 0;
+	session = wrapper->session;
+
+	hPrivateKey = (CK_OBJECT_HANDLE)RSA_get_ex_data(rsa, rsaPrivKey);
+	if (hPrivateKey == CK_INVALID_HANDLE)
+		hPrivateKey = pkcs11_FindOrCreateKey(session, rsa, CKO_PRIVATE_KEY, true);
+
+	if (hPrivateKey != CK_INVALID_HANDLE)
+	{
+		rv = pFunctionList->C_DecryptInit(session, pMechanism, hPrivateKey);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_PRIV_DEC, PKCS11_R_DECRYPTINIT, rv);
+			bytesDecrypted = -1;
+			goto out;
+		}
+
+		rv = pFunctionList->C_Decrypt(session, (unsigned char *)from,
+				flen, to, &bytesDecrypted);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_PRIV_DEC, PKCS11_R_DECRYPT, rv);
+			bytesDecrypted = -1;
+			goto out;
+		}
+	}
+out:
+	OPENSSL_free(wrapper);
+	return bytesDecrypted;
+}
+
+
+
+/*----------------------------------------------------------------*/
+/* pkcs11_RSA_public_decrypt */
+/* */
+/* This function implements RSA public decryption, the rsaKey
+   variable is the public key (but can be a private key).
+   This function should be processed as a pkcs11
+   verify-recover function
+flen : bytes are taken from 'from' and decrypted.
+to : The decrypted data.
+ret : The number of bytes encrypted. -1 is returned to indicate an error.
+The operation performed is to = from^rsa->e mod rsa->n.*/
+/* for PKCS11 use C_VerifyRecoverInit + C_VerifyRecover */
+/*'from' points to signature and 'flen' contains its length*/
+/*----------------------------------------------------------------*/
+static int pkcs11_RSA_public_decrypt(int flen,
+		const unsigned char *from,
+		unsigned char *to,
+		RSA *rsa,
+		int padding)
+{
+	CK_ULONG bytesDecrypted = 0;
+	CK_RV rv;
+	CK_MECHANISM Mechanism_rsa = {CKM_RSA_PKCS, NULL, 0};
+	CK_MECHANISM *pMechanism = &Mechanism_rsa;
+	CK_OBJECT_HANDLE hPublicKey = CK_INVALID_HANDLE;
+	struct token_session *wrapper = NULL;
+	CK_SESSION_HANDLE session;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	if (padding != RSA_PKCS1_PADDING)
+	{
+		PKCS11err(PKCS11_F_RSA_PUB_DEC, PKCS11_R_UNKNOWN_PADDING_TYPE);
+		return -1;
+	}
+
+	wrapper = pkcs11_getSession();
+	if (!wrapper)
+		return 0;
+	session = wrapper->session;
+
+	hPublicKey = (CK_OBJECT_HANDLE)RSA_get_ex_data(rsa, rsaPubKey);
+	if (hPublicKey == CK_INVALID_HANDLE)
+		hPublicKey = pkcs11_FindOrCreateKey(session, rsa, CKO_PUBLIC_KEY, true);
+
+	if (hPublicKey != CK_INVALID_HANDLE)
+	{
+		rv = pFunctionList->C_VerifyRecoverInit(session, pMechanism, hPublicKey);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_PUB_DEC, PKCS11_R_VERIFYRECOVERINIT, rv);
+			bytesDecrypted = -1;
+			goto out;
+		}
+
+		rv = pFunctionList->C_VerifyRecover(session, (unsigned char *)from,
+				flen, NULL_PTR, &bytesDecrypted);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_PUB_DEC, PKCS11_R_VERIFYRECOVER, rv);
+			bytesDecrypted = -1;
+			goto out;
+		}
+		rv = pFunctionList->C_VerifyRecover(session, (unsigned char *)from,
+				flen, to, &bytesDecrypted);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_PUB_DEC, PKCS11_R_VERIFYRECOVER, rv);
+			bytesDecrypted = -1;
+			goto out;
+		}
+	}
+
+out:
+	OPENSSL_free(wrapper);
+	return bytesDecrypted;
+}
+
+static int pkcs11_RSA_init(RSA *rsa)
+{
+	DBG_fprintf("%s\n", __FUNCTION__);
+#if 0 /* FIXME !! */
+	rsa->flags |= RSA_FLAG_GEN_KEY | RSA_FLAG_SIGN_VER;
+#else
+	rsa->flags |=  RSA_FLAG_SIGN_VER;
+#endif
+	RSA_blinding_off(rsa);
+	return 1;
+}
+
+static int pkcs11_RSA_finish(RSA *rsa)
+{
+	CK_RV rv;
+	CK_OBJECT_HANDLE hPublicKey = CK_INVALID_HANDLE;
+	CK_OBJECT_HANDLE hPrivateKey = CK_INVALID_HANDLE;
+	unsigned int deletePubKey;
+	unsigned int deletePrivKey;
+	struct token_session *wrapper = NULL;
+	CK_SESSION_HANDLE session;
+	int err = 0;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	if (rsa->_method_mod_n != NULL)
+		BN_MONT_CTX_free(rsa->_method_mod_n);
+	if (rsa->_method_mod_p != NULL)
+		BN_MONT_CTX_free(rsa->_method_mod_p);
+	if (rsa->_method_mod_q != NULL)
+		BN_MONT_CTX_free(rsa->_method_mod_q);
+
+	deletePrivKey = (unsigned int)RSA_get_ex_data(rsa, deletePrivKeyOnFree);
+	hPrivateKey = (CK_OBJECT_HANDLE)RSA_get_ex_data(rsa, rsaPrivKey);
+
+	wrapper = pkcs11_getSession();
+	if (!wrapper)
+		return 0;
+	session = wrapper->session;
+
+	if ((deletePrivKey) && (hPrivateKey != CK_INVALID_HANDLE))
+	{
+		rv = pFunctionList->C_DestroyObject(session, hPrivateKey);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_FINISH, PKCS11_R_DESTROYOBJECT, rv);
+			goto out;
+		}
+		hPrivateKey = CK_INVALID_HANDLE;
+		RSA_set_ex_data(rsa, rsaPrivKey, (void *)hPrivateKey);
+		deletePrivKey = FALSE;
+		RSA_set_ex_data(rsa, deletePrivKeyOnFree, (void *)deletePrivKey);
+	}
+
+	deletePubKey = (unsigned int)RSA_get_ex_data(rsa, deletePubKeyOnFree);
+	hPublicKey = (CK_OBJECT_HANDLE)RSA_get_ex_data(rsa, rsaPubKey);
+
+	if ((deletePubKey) && (hPublicKey != CK_INVALID_HANDLE))
+	{
+		rv = pFunctionList->C_DestroyObject(session, hPublicKey);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_FINISH, PKCS11_R_DESTROYOBJECT, rv);
+			goto out;
+		}
+		hPublicKey = CK_INVALID_HANDLE;
+		RSA_set_ex_data(rsa, rsaPubKey, (void *)hPublicKey);
+		deletePubKey = FALSE;
+		RSA_set_ex_data(rsa, deletePubKeyOnFree, (void *)deletePubKey);
+	}
+	err = 1;
+out:
+	OPENSSL_free(wrapper);
+	return err;
+}
+
+static int pkcs11_RSA_sign(int type,
+		const unsigned char *m,
+		unsigned int m_len,
+		unsigned char *sigret,
+		unsigned int *siglen,
+		const RSA *rsa)
+{
+	X509_SIG sig;
+	ASN1_TYPE parameter;
+	int i,j;
+	unsigned char *p,*s = NULL;
+	X509_ALGOR algor;
+	ASN1_OCTET_STRING digest;
+	CK_RV rv;
+	CK_MECHANISM Mechanism_rsa = {CKM_RSA_PKCS, NULL, 0};
+	CK_MECHANISM *pMechanism = &Mechanism_rsa;
+	CK_OBJECT_HANDLE hPrivateKey;
+	int ret = 0;
+	struct token_session *wrapper = NULL;
+	CK_SESSION_HANDLE session;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	/* Encode the digest	*/
+	/* Special case: SSL signature, just check the length */
+	if(type == NID_md5_sha1)
+	{
+		if(m_len != SSL_SIG_LENGTH)
+		{
+			PKCS11err(PKCS11_F_RSA_SIGN, PKCS11_R_INVALID_MESSAGE_LENGTH);
+			return 0;
+		}
+		i = SSL_SIG_LENGTH;
+		s = (unsigned char *)m;
+	}
+	else
+	{
+		sig.algor= &algor;
+		sig.algor->algorithm=OBJ_nid2obj(type);
+		if (sig.algor->algorithm == NULL)
+		{
+			PKCS11err(PKCS11_F_RSA_SIGN, PKCS11_R_UNKNOWN_ALGORITHM_TYPE);
+			return 0;
+		}
+		if (sig.algor->algorithm->length == 0)
+		{
+			PKCS11err(PKCS11_F_RSA_SIGN, PKCS11_R_UNKNOWN_ASN1_OBJECT_ID);
+			return 0;
+		}
+		parameter.type=V_ASN1_NULL;
+		parameter.value.ptr=NULL;
+		sig.algor->parameter= &parameter;
+
+		sig.digest= &digest;
+		sig.digest->data=(unsigned char *)m;
+		sig.digest->length=m_len;
+
+		i=i2d_X509_SIG(&sig,NULL);
+	}
+
+	j=RSA_size(rsa);
+	if ((i-RSA_PKCS1_PADDING) > j)
+	{
+		PKCS11err(PKCS11_F_RSA_SIGN, PKCS11_R_DIGEST_TOO_BIG);
+		return 0;
+	}
+
+	if(type != NID_md5_sha1)
+	{
+		s=(unsigned char *)OPENSSL_malloc((unsigned int)j+1);
+		if (s == NULL)
+		{
+			PKCS11err(PKCS11_F_RSA_SIGN, PKCS11_R_MALLOC_FAILURE);
+			return 0;
+		}
+		p=s;
+		i2d_X509_SIG(&sig,&p);
+	}
+
+	wrapper = pkcs11_getSession();
+	if (!wrapper)
+		return 0;
+	session = wrapper->session;
+
+	hPrivateKey = (CK_OBJECT_HANDLE)RSA_get_ex_data(rsa, rsaPrivKey);
+	if (hPrivateKey == CK_INVALID_HANDLE)
+		hPrivateKey = pkcs11_FindOrCreateKey(session, (RSA *)rsa, CKO_PRIVATE_KEY, true);
+
+	if (hPrivateKey != CK_INVALID_HANDLE)
+	{
+		rv = pFunctionList->C_SignInit(session, pMechanism, hPrivateKey);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_SIGN, PKCS11_R_SIGNINIT, rv);
+			goto err;
+		}
+
+		*siglen = j;
+		rv = pFunctionList->C_Sign(session, s, i, sigret, (CK_ULONG_PTR)siglen);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_SIGN, PKCS11_R_SIGN, rv);
+			goto err;
+		}
+		ret = 1;
+	}
+
+err:
+	if(type != NID_md5_sha1)
+	{
+		memset(s,0,(unsigned int)j+1);
+		OPENSSL_free(s);
+	}
+
+	OPENSSL_free(wrapper);
+
+	return ret;
+}
+
+static int pkcs11_RSA_verify(int type,
+		const unsigned char *m,
+		unsigned int m_len,
+		unsigned char *sigbuf,
+		unsigned int siglen,
+		const RSA *rsa)
+{
+	X509_SIG sig;
+	ASN1_TYPE parameter;
+	int i,j;
+	unsigned char *p,*s = NULL;
+	X509_ALGOR algor;
+	ASN1_OCTET_STRING digest;
+	CK_RV rv;
+	CK_MECHANISM Mechanism_rsa = {CKM_RSA_PKCS, NULL, 0};
+	CK_MECHANISM *pMechanism = &Mechanism_rsa;
+	CK_OBJECT_HANDLE hPublicKey;
+	int ret = 0;
+	struct token_session *wrapper = NULL;
+	CK_SESSION_HANDLE session;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	/* Encode the digest	*/
+	/* Special case: SSL signature, just check the length */
+	if(type == NID_md5_sha1)
+	{
+		if(m_len != SSL_SIG_LENGTH)
+		{
+			PKCS11err(PKCS11_F_RSA_VERIFY, PKCS11_R_INVALID_MESSAGE_LENGTH);
+			return 0;
+		}
+		i = SSL_SIG_LENGTH;
+		s = (unsigned char *)m;
+	}
+	else
+	{
+		sig.algor= &algor;
+		sig.algor->algorithm=OBJ_nid2obj(type);
+		if (sig.algor->algorithm == NULL)
+		{
+			PKCS11err(PKCS11_F_RSA_VERIFY, PKCS11_R_UNKNOWN_ALGORITHM_TYPE);
+			return 0;
+		}
+		if (sig.algor->algorithm->length == 0)
+		{
+			PKCS11err(PKCS11_F_RSA_VERIFY, PKCS11_R_UNKNOWN_ASN1_OBJECT_ID);
+			return 0;
+		}
+		parameter.type=V_ASN1_NULL;
+		parameter.value.ptr=NULL;
+		sig.algor->parameter= &parameter;
+		sig.digest= &digest;
+		sig.digest->data=(unsigned char *)m;
+		sig.digest->length=m_len;
+		i=i2d_X509_SIG(&sig,NULL);
+	}
+
+	j=RSA_size(rsa);
+	if ((i-RSA_PKCS1_PADDING) > j)
+	{
+		PKCS11err(PKCS11_F_RSA_VERIFY, PKCS11_R_DIGEST_TOO_BIG);
+		return 0;
+	}
+
+	if(type != NID_md5_sha1)
+	{
+		s=(unsigned char *)OPENSSL_malloc((unsigned int)j+1);
+		if (s == NULL)
+		{
+			PKCS11err(PKCS11_F_RSA_VERIFY, PKCS11_R_MALLOC_FAILURE);
+			return 0;
+		}
+		p=s;
+		i2d_X509_SIG(&sig,&p);
+	}
+
+	wrapper = pkcs11_getSession();
+	if (!wrapper)
+		return 0;
+	session = wrapper->session;
+
+	hPublicKey = (CK_OBJECT_HANDLE)RSA_get_ex_data(rsa, rsaPubKey);
+	if (hPublicKey == CK_INVALID_HANDLE)
+		hPublicKey = pkcs11_FindOrCreateKey(session, (RSA *)rsa, CKO_PUBLIC_KEY, true);
+
+	if (hPublicKey != CK_INVALID_HANDLE)
+	{
+		rv = pFunctionList->C_VerifyInit(session, pMechanism, hPublicKey);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_VERIFY, PKCS11_R_VERIFYINIT, rv);
+			goto err;
+		}
+		rv = pFunctionList->C_Verify(session, s, i, sigbuf, (CK_ULONG)siglen);
+		if (rv != CKR_OK)
+		{
+			pkcs11_die(PKCS11_F_RSA_VERIFY, PKCS11_R_VERIFY, rv);
+			goto err;
+		}
+		ret = 1;
+	}
+
+err:
+	if(type != NID_md5_sha1)
+	{
+		memset(s,0,(unsigned int)siglen);
+		OPENSSL_free(s);
+	}
+	OPENSSL_free(wrapper);
+
+	return ret;
+}
+
+static int pkcs11_RSA_generate_key_with_mechanism(RSA* rsa,
+		CK_MECHANISM *pMechanism,
+		int bits,
+		unsigned long e_value,
+		void (*callback)(int,int,void *),
+		void *cb_arg, CK_BBOOL token)
+{
+	CK_ULONG i;
+	CK_OBJECT_HANDLE hPublicKey;
+	CK_OBJECT_HANDLE hPrivateKey;
+	CK_OBJECT_CLASS oPublicKey = CKO_PUBLIC_KEY;
+	CK_OBJECT_CLASS oPrivateKey = CKO_PRIVATE_KEY;
+	CK_KEY_TYPE kType = CKK_RSA;
+	CK_ULONG ulPublicKeyAttributeCount = 8; 
+	CK_ATTRIBUTE aPublicKeyTemplate[] =
+	{
+		{CKA_CLASS, &oPublicKey, sizeof(CK_OBJECT_CLASS)},
+		{CKA_TOKEN, (void *)NULL, 0},
+		{CKA_PRIVATE, &false, sizeof(CK_BBOOL)},
+		{CKA_MODIFIABLE, &false, sizeof(false)},
+		{CKA_KEY_TYPE, &kType, sizeof(CK_KEY_TYPE)},
+		{CKA_MODULUS_BITS, (void *)&bits, sizeof(bits)},
+		{CKA_PUBLIC_EXPONENT, (void *)NULL, 0},
+		{CKA_ID, PKCS11_KEY_ID, 8}
+	};
+	CK_ULONG	 ulPublicKeyAttributeResultCount = 2;
+	CK_ATTRIBUTE aPublicKeyResult[] =
+	{
+		{CKA_MODULUS, (void *)NULL, 0},
+		/* {CKA_MODULUS_BITS, (void *)NULL, 0}, */
+		{CKA_PUBLIC_EXPONENT, (void *)NULL, 0}
+	};
+	CK_ULONG	ulPrivateKeyAttributeCount = 12; 
+	CK_ATTRIBUTE    aPrivateKeyTemplate[] =
+	{
+		{CKA_CLASS, &oPrivateKey, sizeof(CK_OBJECT_CLASS)},
+		{CKA_TOKEN, (void *)NULL, 0},
+		{CKA_PRIVATE, &false, sizeof(CK_BBOOL)},
+		{CKA_MODIFIABLE, &false, sizeof(CK_BBOOL)},
+		{CKA_KEY_TYPE, &kType, sizeof(CK_KEY_TYPE)},
+		{CKA_SENSITIVE, &true, sizeof(CK_BBOOL)},
+		{CKA_DECRYPT, &true, sizeof(CK_BBOOL)},
+		{CKA_SIGN, &true, sizeof(CK_BBOOL)},
+		{CKA_SIGN_RECOVER, &true, sizeof(CK_BBOOL)},
+		{CKA_UNWRAP, &true, sizeof(CK_BBOOL)},
+		{CKA_EXTRACTABLE, &true, sizeof(CK_BBOOL)},
+		{CKA_ID, PKCS11_KEY_ID, 8}
+	};
+	CK_RV rv;
+	CK_ATTRIBUTE *pModulus = NULL;
+	CK_ATTRIBUTE *pExponent = NULL;
+	BIGNUM	*bn_e=NULL;
+	int ret = 1;
+	struct token_session *wrapper = NULL;
+	CK_SESSION_HANDLE session;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	bn_e = BN_new();
+	if (bn_e == NULL)
+		goto err;
+	/* The problem is when building with 8, 16, or 32 BN_ULONG,
+	 * unsigned long can	 be larger	 */
+	for (i=0; i<sizeof(unsigned long)*8; i++)
+	{
+		if (e_value & (1UL<<i))
+			BN_set_bit(bn_e,i);
+	}
+
+	aPublicKeyTemplate[6].ulValueLen = BN_num_bytes(bn_e);
+	aPublicKeyTemplate[6].pValue = OPENSSL_malloc(aPublicKeyTemplate[6].ulValueLen);
+	i = BN_bn2bin(bn_e, aPublicKeyTemplate[6].pValue);
+	aPublicKeyTemplate[1].ulValueLen = sizeof(token);
+	aPublicKeyTemplate[1].pValue = &token;
+	aPrivateKeyTemplate[1].ulValueLen = sizeof(token);
+	aPrivateKeyTemplate[1].pValue = &token;
+
+	wrapper = pkcs11_getSession();
+	if (!wrapper)
+		return 0;
+	session = wrapper->session;
+
+	rv = pFunctionList->C_GenerateKeyPair(session,
+			pMechanism,
+			aPublicKeyTemplate,
+			ulPublicKeyAttributeCount,
+			aPrivateKeyTemplate,
+			ulPrivateKeyAttributeCount,
+			&hPublicKey,
+			&hPrivateKey);
+	if (rv != CKR_OK)
+	{
+		pkcs11_die(PKCS11_F_RSA_GEN_KEY, PKCS11_R_GEN_KEY, rv);
+		ret = 0;
+		goto err;
+	}
+
+	rv = pFunctionList->C_GetAttributeValue(session, hPublicKey, aPublicKeyResult, ulPublicKeyAttributeResultCount);
+
+	switch(rv) 
+	{
+		case CKR_OK:
+			for(i = 0; i < ulPublicKeyAttributeResultCount; i++) 
+			{ /* Al	locate required buffers */
+				if (((CK_LONG) aPublicKeyResult[i].ulValueLen) == -1) 
+				{ /* can't get this attribute */
+					PKCS11err(PKCS11_F_RSA_GEN_KEY, PKCS11_R_NO_MODULUS_OR_NO_EXPONENT);
+					goto err;
+				}
+				else 
+				{
+					aPublicKeyResult[i].pValue = OPENSSL_malloc(aPublicKeyResult[i].ulValueLen);
+					if (!aPublicKeyResult[i].pValue)
+					{
+						PKCS11err(PKCS11_F_RSA_GEN_KEY, PKCS11_R_GEN_KEY);
+						goto err;
+					}
+				}
+			}
+			break;
+		case CKR_ATTRIBUTE_SENSITIVE:
+		case CKR_ATTRIBUTE_TYPE_INVALID:
+			PKCS11err(PKCS11_F_RSA_GEN_KEY, PKCS11_R_ATTRIBUT_SENSITIVE_OR_INVALID);
+			goto err;
+		default:
+			PKCS11err(PKCS11_F_RSA_GEN_KEY, PKCS11_R_GETATTRIBUTVALUE);
+			goto err;
+	}
+	/*	 Then get the values */
+	rv = pFunctionList->C_GetAttributeValue(session, hPublicKey, aPublicKeyResult,ulPublicKeyAttributeResultCount);
+	switch(rv) 
+	{
+		case CKR_OK:
+			break;
+		case CKR_ATTRIBUTE_SENSITIVE:
+		case CKR_ATTRIBUTE_TYPE_INVALID:
+			PKCS11err(PKCS11_F_RSA_GEN_KEY, PKCS11_R_ATTRIBUT_SENSITIVE_OR_INVALID);
+			goto err;
+		default:
+			PKCS11err(PKCS11_F_RSA_GEN_KEY, PKCS11_R_GETATTRIBUTVALUE);
+			goto err;
+	}
+
+	/* recherche du Modulus */ 
+	for(i = 0; i < ulPublicKeyAttributeResultCount; i++) 
+	{
+		if (aPublicKeyResult[i].type == CKA_MODULUS)
+		{
+			if (((CK_LONG) aPublicKeyResult[i].ulValueLen) != -1) 
+			{
+				pModulus = &(aPublicKeyResult[i]);
+			}
+			break;
+		}
+	}
+	if (pModulus == NULL)
+	{
+		PKCS11err(PKCS11_F_RSA_GEN_KEY, PKCS11_R_NO_MODULUS);
+		goto err;
+	}
+	/* 	set n */ 
+	rsa->n = BN_bin2bn(pModulus->pValue, pModulus->ulValueLen, rsa->n);
+
+	/*	 search Exponent */
+	for(i = 0; i < ulPublicKeyAttributeResultCount; i++) 
+	{
+		if (aPublicKeyResult[i].type == CKA_PUBLIC_EXPONENT)
+		{
+			if (((CK_LONG) aPublicKeyResult[i].ulValueLen) != -1) 
+			{
+				pExponent = &(aPublicKeyResult[i]);
+			}
+			break;
+		}
+	}
+	if (pExponent == NULL)
+	{
+		PKCS11err(PKCS11_F_RSA_GEN_KEY, PKCS11_R_NO_EXPONENT);
+		goto err;
+	}
+	/* 	set e */ 
+	rsa->e = bn_e;
+	bn_e = NULL;
+
+	RSA_set_ex_data(rsa, rsaPubKey, (char *)hPublicKey);
+	RSA_set_ex_data(rsa, rsaPrivKey, (char *)hPrivateKey);
+
+err:
+	for(i = 0; i < ulPublicKeyAttributeResultCount; i++) 
+	{
+		if (aPublicKeyResult[i].pValue)
+		{ 
+			OPENSSL_free(aPublicKeyResult[i].pValue);
+			aPublicKeyResult[i].pValue = NULL;
+		}
+	}
+	if (aPublicKeyTemplate[6].pValue != NULL)
+	{
+		OPENSSL_free(aPublicKeyTemplate[6].pValue);
+		aPublicKeyTemplate[6].pValue = NULL;
+	}
+	if (bn_e != NULL)
+		BN_free(bn_e);
+
+	OPENSSL_free(wrapper);
+
+	return ret;
+}
+
+/* ************************************************************ */
+/*								*/
+/*	function :	pkcs11_RSA_generate_key		*/
+/*								*/
+/* ************************************************************ */
+static int pkcs11_RSA_generate_key(RSA* rsa,
+		int bits,
+		unsigned long e_value,
+		void (*callback)(int,int,void *),
+		void *cb_arg)
+{
+	CK_MECHANISM Mechanism = {CKM_RSA_PKCS_KEY_PAIR_GEN, NULL_PTR, 0};
+	CK_BBOOL token = TRUE;
+
+	return pkcs11_RSA_generate_key_with_mechanism(rsa, &Mechanism, bits, e_value, callback, cb_arg, token);
+}
+
+RSA* pkcs11_RSA_generate_tmp_key(int bits,unsigned long e_value,void (*callback)(int,int,void *),void *cb_arg)
+{
+	RSA		*rsa;
+	CK_MECHANISM	Mechanism = {CKM_RSA_PKCS_KEY_PAIR_GEN, NULL_PTR, 0};
+	CK_BBOOL	token = FALSE;
+	unsigned int	deleteKey;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	rsa=RSA_new();
+	if (rsa == NULL)
+		return NULL;
+	else
+	{
+		if (pkcs11_RSA_generate_key_with_mechanism(rsa, &Mechanism, bits, e_value, callback, cb_arg, token))
+		{
+			deleteKey = TRUE;
+			RSA_set_ex_data(rsa, deletePubKeyOnFree, (void *)deleteKey);
+			RSA_set_ex_data(rsa, deletePrivKeyOnFree, (void *)deleteKey);
+			return rsa;
+		}
+		else
+			return NULL;
+	}
+}
+
+/* The private is found from the public key stored in PEM format in "pubkey_file" */
+static EVP_PKEY *pkcs11_load_privkey(ENGINE* e, const char* pubkey_file,
+		UI_METHOD *ui_method, void *callback_data)
+{
+	EVP_PKEY *pkey=NULL;
+	FILE *pubkey;
+	CK_OBJECT_HANDLE  hPrivateKey = CK_INVALID_HANDLE;
+	RSA *rsa;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	if ((pubkey=fopen(pubkey_file,"r")) != NULL)
+	{
+		pkey = PEM_read_PUBKEY(pubkey, NULL, NULL, NULL);
+		fclose(pubkey);
+		if (pkey)
+		{
+			rsa = EVP_PKEY_get1_RSA(pkey);
+			if (rsa)
+			{
+				struct token_session *wrapper = NULL;
+				CK_SESSION_HANDLE session;
+
+				wrapper = pkcs11_getSession();
+				if (!wrapper)
+					return 0;
+				session = wrapper->session;
+
+				hPrivateKey = pkcs11_FindOrCreateKey(session, rsa, CKO_PRIVATE_KEY, true);
+				if (hPrivateKey == CK_INVALID_HANDLE)
+				{
+					EVP_PKEY_free(pkey);
+					pkey = NULL;
+				}
+				OPENSSL_free(wrapper);
+			}
+			else
+			{
+				EVP_PKEY_free(pkey);
+				pkey = NULL;
+			}
+		}
+	}
+	return(pkey);
+}
+
+static EVP_PKEY *pkcs11_load_pubkey(ENGINE* e, const char* pubkey_file,
+		UI_METHOD *ui_method, void *callback_data)
+{
+	EVP_PKEY *pkey=NULL;
+	FILE *pubkey;
+	CK_OBJECT_HANDLE  hPublicKey = CK_INVALID_HANDLE;
+	RSA *rsa;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	if ((pubkey=fopen(pubkey_file,"r")) != NULL)
+	{
+		pkey = PEM_read_PUBKEY(pubkey, NULL, NULL, NULL);
+		fclose(pubkey);
+		if (pkey)
+		{
+			rsa = EVP_PKEY_get1_RSA(pkey);
+			if (rsa)
+			{
+				struct token_session *wrapper = NULL;
+				CK_SESSION_HANDLE session;
+
+				wrapper = pkcs11_getSession();
+				if (!wrapper)
+					return 0;
+				session = wrapper->session;
+
+				hPublicKey = pkcs11_FindOrCreateKey(session, rsa, CKO_PUBLIC_KEY, true);
+				if (hPublicKey == CK_INVALID_HANDLE)
+				{
+					EVP_PKEY_free(pkey);
+					pkey = NULL;
+				}
+				OPENSSL_free(wrapper);
+			}
+			else
+			{
+				EVP_PKEY_free(pkey);
+				pkey = NULL;
+			}
+		}
+	}
+	return(pkey);
+}
+
+#endif
+
+static void pkcs11_rand_cleanup(void)
+{
+	return;
+}
+
+static void pkcs11_rand_add(const void *buf,
+		int num,
+		double entropy)
+{
+	CK_RV rv;
+	struct token_session *wrapper;
+ 
+	/* return any token */
+	wrapper = pkcs11_getSession();
+	if (!wrapper)
+		return;
+
+	rv = pFunctionList->C_SeedRandom(wrapper->session, (CK_BYTE_PTR)&entropy, sizeof(entropy));
+	if (rv != CKR_OK)
+	{
+		pkcs11_die(PKCS11_F_RAND_ADD, PKCS11_R_SEEDRANDOM, rv);
+		return; 
+	}
+
+	rv = pFunctionList->C_GenerateRandom(wrapper->session, (CK_BYTE *)buf, num);
+	if (rv != CKR_OK)
+	{
+		pkcs11_die(PKCS11_F_RAND_ADD, PKCS11_R_GENERATERANDOM, rv);
+	}
+
+	pFunctionList->C_CloseSession(wrapper->session);
+	OPENSSL_free(wrapper);
+}
+
+static void pkcs11_rand_seed(const void *buf,
+		int num)
+{
+	pkcs11_rand_add(buf, num, num);
+}
+
+static int pkcs11_rand_bytes(unsigned char *buf,
+		int num)
+{
+	CK_RV rv;
+	struct token_session *wrapper;
+ 
+	/* return any token */
+	wrapper = pkcs11_getSession();
+	if (!wrapper)
+		return 0;
+
+	rv = pFunctionList->C_GenerateRandom(wrapper->session, buf, num);
+	if (rv != CKR_OK)
+	{
+		pkcs11_die(PKCS11_F_RAND_BYTES, PKCS11_R_GENERATERANDOM, rv);
+		pFunctionList->C_CloseSession(wrapper->session);
+		OPENSSL_free(wrapper);
+		return 0;
+	}
+
+	pFunctionList->C_CloseSession(wrapper->session);
+	OPENSSL_free(wrapper);
+	return 1;
+}
+
+static int pkcs11_rand_status(void)
+{
+	return 1;
+}
+
+static int pkcs11_des_init_key(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+		const unsigned char *iv, int enc)
+{
+	return pkcs11_init_key(ctx, key, iv, enc, alg_des);
+}
+
+static int pkcs11_tdes_init_key(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+		const unsigned char *iv, int enc)
+{
+	return pkcs11_init_key(ctx, key, iv, enc, alg_tdes);
+}
+
+static int pkcs11_aes_init_key(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+		const unsigned char *iv, int enc)
+{
+	return pkcs11_init_key(ctx, key, iv, enc, alg_aes);
+}
+
+static inline int get_mech(int alg, EVP_CIPHER_CTX *ctx)
+{
+	switch (alg) {
+		case alg_des:
+			if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_ECB_MODE)
+				return CKM_DES_ECB;
+			else if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_CBC_MODE) {
+				return CKM_DES_CBC;
+			}
+			return -1;
+
+		case alg_tdes:
+			if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_ECB_MODE)
+				return CKM_DES3_ECB;
+			else if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_CBC_MODE) {
+				return CKM_DES3_CBC;
+			}
+			return -1;
+
+		case alg_aes:
+			if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_ECB_MODE) {
+				return CKM_AES_ECB;
+			} else if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_CBC_MODE) {
+				return CKM_AES_CBC;
+			}
+			return -1;
+
+		case alg_sha:
+			return CKM_SHA_1;
+		case alg_md5:
+			return CKM_MD5;
+		case alg_ripemd:
+			return CKM_RIPEMD160;
+		default:
+			return -1;
+	}
+}
+
+static int pkcs11_init_key(EVP_CIPHER_CTX * ctx, const unsigned char *key,
+		const unsigned char *iv, int enc, int alg)
+{
+	int ret = 0;
+	CK_RV rv;
+	CK_MECHANISM_TYPE mech = get_mech(alg, ctx);
+	CK_MECHANISM mechanism = { mech, 
+				   EVP_CIPHER_CTX_mode(ctx)==EVP_CIPH_CBC_MODE ? (void *)iv : NULL, 
+				   EVP_CIPHER_CTX_mode(ctx)==EVP_CIPH_CBC_MODE ? 
+					   EVP_CIPHER_CTX_iv_length(ctx) :
+					   0 };
+	CK_SESSION_HANDLE session;
+	struct _token *token;
+	struct token_session *wrapper = pkcs11_getSession();
+	CK_BBOOL true = TRUE;
+	CK_BBOOL boolenc;
+	CK_OBJECT_CLASS class = CKO_SECRET_KEY;
+	CK_KEY_TYPE keyType;
+	/* A secret key template */
+	CK_ATTRIBUTE template[] = {
+		{CKA_CLASS, &class, sizeof(class)},
+		{CKA_KEY_TYPE, &keyType, sizeof(keyType)},
+		{CKA_TOKEN, &true, sizeof(true)},
+		{CKA_ENCRYPT, &boolenc, sizeof(boolenc)},
+		{CKA_VALUE, (void *)key, EVP_CIPHER_CTX_key_length(ctx)}
+	};
+	
+	/* and finally a cryptoki key handle */
+	CK_OBJECT_HANDLE hkey;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	if (mech==-1) {
+		PKCS11err(PKCS11_F_INITKEY, PKCS11_R_BADMECHANISM);
+		goto out;
+	}
+
+	if (!wrapper) 
+		goto out;
+	
+	/* Save the token number and session ID in the cipher context's
+	 * private data area. The operation will have to continue on this
+	 * token later.
+	 */
+	token = wrapper->token;
+	session = wrapper->session;
+	CIPHER_DATA(ctx)->token = token;
+	CIPHER_DATA(ctx)->session = session;
+	OPENSSL_free(wrapper);
+
+	switch (alg) {
+		case alg_des:
+			keyType = CKK_DES;
+			break;
+		case alg_tdes:
+			keyType = CKK_DES3;
+			break;
+		case alg_aes:
+			keyType = CKK_AES;
+			break;
+		default:
+			PKCS11err(PKCS11_F_INITKEY, PKCS11_R_UNKNOWN_ALGORITHM_TYPE);
+			ERR_add_error_data(1, alg_to_string(alg));
+			goto out_closesession;
+			break;
+	}
+
+	boolenc = (enc ? TRUE : FALSE);
+
+	rv = pFunctionList->C_CreateObject(session, template, 5, &hkey);
+	if (rv != CKR_OK) {
+		pkcs11_die(PKCS11_F_INITKEY, PKCS11_R_CREATEOBJECT, rv);
+		goto out_closesession;
+	}
+
+	if (enc) {
+		rv = pFunctionList->C_EncryptInit(session, &mechanism, hkey);
+		if (rv != CKR_OK) {
+			pkcs11_die(PKCS11_F_INITKEY, PKCS11_R_ENCRYPTINIT, rv);
+			goto out_closesession;
+		}
+	} else {
+		rv = pFunctionList->C_DecryptInit(session, &mechanism, hkey);
+		if (rv != CKR_OK) {
+			pkcs11_die(PKCS11_F_INITKEY, PKCS11_R_DECRYPTINIT, rv);
+			goto out_closesession;
+		}
+	}
+
+	ret = 1;
+
+	goto out;
+
+out_closesession:
+	/* Execute only if we opened a session, but then failed */
+	pFunctionList->C_CloseSession(session);
+
+out:
+	return ret;
+}   // end pkcs11_init_key
+
+static int
+pkcs11_cipher_cleanup(EVP_CIPHER_CTX *ctx)
+{
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+	pFunctionList->C_CloseSession(CIPHER_DATA(ctx)->session);
+	CIPHER_DATA(ctx)->session = CK_INVALID_HANDLE;
+	return 1;
+}
+
+static inline int pkcs11_cipher(EVP_CIPHER_CTX * ctx, unsigned char *out,
+		const unsigned char *in, unsigned int inlen)
+{
+	unsigned long outlen = inlen;
+	CK_RV rv;
+	CK_SESSION_HANDLE session;
+
+	DBG_fprintf("%s\n", __FUNCTION__);
+
+	session = CIPHER_DATA(ctx)->session;
+
+	if (ctx->encrypt) {
+		rv = pFunctionList->C_EncryptUpdate(session, (void *)in, inlen, (void *)out, &outlen);
+
+		if (rv) {
+			pkcs11_die(PKCS11_F_CIPHER_UPDATE, PKCS11_R_ENCRYPT, rv);
+			return 0;
+		} 
+	} else {
+		rv = pFunctionList->C_DecryptUpdate(session, (void *)in, inlen, (void *)out, &outlen);
+
+		if (rv) {
+			pkcs11_die(PKCS11_F_CIPHER_UPDATE, PKCS11_R_DECRYPT, rv);
+			return 0;
+		} 
+	}
+
+	return 1;
+}
+
+static inline int
+pkcs11_sha1_init(EVP_MD_CTX *ctx)
+{
+	return pkcs11_digest_init(ctx, alg_sha);
+}
+static inline int
+pkcs11_sha224_init(EVP_MD_CTX *ctx)
+{
+	return pkcs11_digest_init(ctx, alg_sha224);
+}
+static inline int
+pkcs11_sha256_init(EVP_MD_CTX *ctx)
+{
+	return pkcs11_digest_init(ctx, alg_sha256);
+}
+static inline int
+pkcs11_sha384_init(EVP_MD_CTX *ctx)
+{
+	return pkcs11_digest_init(ctx, alg_sha384);
+}
+static inline int
+pkcs11_sha512_init(EVP_MD_CTX *ctx)
+{
+	return pkcs11_digest_init(ctx, alg_sha512);
+}
+
+static inline int
+pkcs11_md5_init(EVP_MD_CTX *ctx)
+{
+	return pkcs11_digest_init(ctx, alg_md5);
+}
+
+static inline int
+pkcs11_ripemd_init(EVP_MD_CTX *ctx)
+{
+	return pkcs11_digest_init(ctx, alg_ripemd);
+}
+
+static inline int
+pkcs11_digest_init(EVP_MD_CTX *ctx, int alg)
+{
+	struct pkcs11_digest_ctx *ctx_data = ctx->md_data;
+
+	memset(ctx_data, 0, sizeof(struct pkcs11_digest_ctx));
+	ctx_data->alg = alg;
+	ctx_data->ref_cnt = OPENSSL_malloc(sizeof(int));
+	*ctx_data->ref_cnt = 0;
+
+	return 1;
+}
+
+static int
+pkcs11_digest_update(EVP_MD_CTX *ctx, const void *in, ulong len)
+{
+	struct pkcs11_digest_ctx *ctx_data;
+
+	if (!MD_DATA(ctx)) {
+		PKCS11err(PKCS11_F_DIGESTUPDATE, PKCS11_R_PASSED_NULL_PARAMETER);
+		return 0;
+	}
+
+	ctx_data = (struct pkcs11_digest_ctx *)MD_DATA(ctx);
+	
+	while (len + ctx_data->len > ctx_data->size) {
+		ctx_data->size += PKCS11_DIGEST_BLOCK_SIZE;
+		ctx_data->data = realloc(ctx_data->data, ctx_data->size);
+	}
+
+	memcpy(ctx_data->data + ctx_data->len, in, len);
+	ctx_data->len += len;
+	
+	return 1;
+}
+
+static int
+pkcs11_digest_finish(EVP_MD_CTX *ctx, unsigned char *md)
+{
+	CK_ULONG len = EVP_MD_CTX_size(ctx);
+	CK_RV rv;
+	struct pkcs11_digest_ctx *data = (struct pkcs11_digest_ctx *)MD_DATA(ctx);
+	int ret = 0, alg = data->alg;
+	struct token_session *wrapper = pkcs11_getSession();
+	CK_MECHANISM_TYPE mech = get_mech(alg, NULL);
+	CK_MECHANISM mechanism = {mech, NULL, 0};
+
+	if (!wrapper)
+		goto out;
+
+	switch (alg) {
+		case alg_sha:
+			mech = CKM_SHA_1;
+			break;
+		case alg_sha224:
+			mech = CKM_SHA224;
+			break;
+		case alg_sha256:
+			mech = CKM_SHA256;
+			break;
+		case alg_sha384:
+			mech = CKM_SHA384;
+			break;
+		case alg_sha512:
+			mech = CKM_SHA512;
+			break;
+		case alg_md5:
+			mech = CKM_MD5;
+			break;
+		case alg_ripemd:
+			mech = CKM_RIPEMD160;
+			break;
+		default:
+			PKCS11err(PKCS11_F_DIGESTFINISH, PKCS11_R_UNKNOWN_ALGORITHM_TYPE);
+			ERR_add_error_data(1, alg_to_string(alg));
+			goto out_endsession;
+			break;
+	}
+
+	rv = pFunctionList->C_DigestInit(wrapper->session, &mechanism);
+	if (rv != CKR_OK) {
+		pkcs11_die(PKCS11_F_DIGESTFINISH, PKCS11_R_DIGESTINIT, rv);
+		goto out_endsession;
+	}
+
+	rv = pFunctionList->C_Digest(wrapper->session, data->data, data->len, md, &len);
+	if (rv != CKR_OK) {
+		pkcs11_die(PKCS11_F_DIGESTFINISH, PKCS11_R_DIGEST, rv);
+		goto out_endsession;
+	}
+
+	if (*data->ref_cnt == 0) {
+		OPENSSL_free(data->data);
+		OPENSSL_free(data->ref_cnt);
+	} else
+		(*data->ref_cnt)--;
+
+	memset(data, 0, sizeof(struct pkcs11_digest_ctx));
+	ret = 1;
+	
+out_endsession:
+	pFunctionList->C_CloseSession(wrapper->session);
+	OPENSSL_free(wrapper);
+out:
+	return ret;
+}
+
+static int
+pkcs11_digest_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in)
+{
+	struct pkcs11_digest_ctx *data = out->md_data;
+	struct pkcs11_digest_ctx *indata = in->md_data;
+
+#if 0
+	/* TODO: change this to a refcount */
+	data->data = (char *)OPENSSL_malloc(data->len);
+	memcpy(data->data, indata->data, data->len);
+#endif
+
+	*(data->ref_cnt)++;
+	
+	return 1;
+}
+
+static inline int
+pkcs11_digest_cleanup(EVP_MD_CTX *ctx)
+{
+	return 1;
+}
+#endif
+#endif
+
diff -urN openssl-0.9.8e/engines/e_pkcs11_err.c openssl-0.9.8e.new/engines/e_pkcs11_err.c
--- openssl-0.9.8e/engines/e_pkcs11_err.c	1970-01-01 10:00:00.000000000 +1000
+++ openssl-0.9.8e.new/engines/e_pkcs11_err.c	2008-06-13 09:45:21.000000000 +1000
@@ -0,0 +1,144 @@
+/* hw_pkcs11_err.c */
+/*
+ * PKCS#11 engine for the OpenSSL project 2002
+ * Developped by Bull Trustway R&D Networking & Security
+ * Introduced and tested with Bull TrustWay CC2000 crypto hardware
+ * Afchine.Madjlessi@bull.net Bull S.A. France
+ * http://www.servers.bull.com/trustway
+ */
+
+#include <stdio.h>
+#include <openssl/err.h>
+#include "e_pkcs11_err.h"
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+static ERR_STRING_DATA pkcs11_str_functs[]=
+{
+    {ERR_PACK(0,PKCS11_F_INIT,0),	    "PKCS11_INIT"},
+    {ERR_PACK(0,PKCS11_F_FINISH,0),	    "PKCS11_FINISH"},
+    {ERR_PACK(0,PKCS11_F_DESTROY,0),	    "PKCS11_DESTROY"},
+    {ERR_PACK(0,PKCS11_F_CTRL,0),	    "PKCS11_CTRL"},
+    {ERR_PACK(0,PKCS11_F_RSA_INIT,0),	    "PKCS11_RSA_INIT"},
+    {ERR_PACK(0,PKCS11_F_RSA_FINISH,0),	    "PKCS11_RSA_FINISH"},
+    {ERR_PACK(0,PKCS11_F_FINDORCREATEKEY,0),"PKCS11_FINDORCREATEKEY"},
+    {ERR_PACK(0,PKCS11_F_RSA_GEN_KEY,0),    "PKCS11_RSA_GEN_KEY"},
+    {ERR_PACK(0,PKCS11_F_RSA_PUB_ENC,0),    "PKCS11_RSA_PUB_ENC"},
+    {ERR_PACK(0,PKCS11_F_RSA_PRIV_ENC,0),   "PKCS11_RSA_PRIV_ENC"},
+    {ERR_PACK(0,PKCS11_F_RSA_PUB_DEC,0),    "PKCS11_RSA_PUB_DEC"},
+    {ERR_PACK(0,PKCS11_F_RSA_PRIV_DEC,0),   "PKCS11_RSA_PRIV_DEC"},
+    {ERR_PACK(0,PKCS11_F_RSA_SIGN,0),	    "PKCS11_RSA_SIGN"},
+    {ERR_PACK(0,PKCS11_F_RSA_VERIFY,0),	    "PKCS11_RSA_VERIFY"},
+    {ERR_PACK(0,PKCS11_F_RAND_ADD,0),	    "PKCS11_RAND_ADD"},
+    {ERR_PACK(0,PKCS11_F_RAND_BYTES,0),	    "PKCS11_RAND_BYTES"},
+    {ERR_PACK(0,PKCS11_F_GETSESSION,0),	    "PKCS11_GETSESSION"},
+    {ERR_PACK(0,PKCS11_F_FREESESSION,0),    "PKCS11_FREESESSION"},
+    {ERR_PACK(0,PKCS11_F_INITKEY,0),        "PKCS11_INITKEY"},
+    {ERR_PACK(0,PKCS11_F_DIGESTINIT,0),    "PKCS11_DIGESTINIT"},
+    {ERR_PACK(0,PKCS11_F_DIGESTUPDATE,0),    "PKCS11_DIGESTUPDATE"},
+    {ERR_PACK(0,PKCS11_F_DIGESTFINISH,0),    "PKCS11_DIGESTFINISH"},
+    {ERR_PACK(0,PKCS11_F_CIPHER_UPDATE,0),    "PKCS11_CIPHER_UPDATE"},
+    {ERR_PACK(0,PKCS11_F_PREINIT,0),    "PKCS11_PREINIT"},
+    {ERR_PACK(0,PKCS11_F_ADDTOKEN,0),    "PKCS11_ADDTOKEN"},
+    {ERR_PACK(0,PKCS11_F_LOAD_PRIVKEY,0),    "PKCS11_LOAD_PRIVKEY"},
+    {ERR_PACK(0,PKCS11_F_LOAD_PUBKEY,0),    "PKCS11_LOAD_PUBKEY"},
+    {ERR_PACK(0,PKCS11_F_DIGESTCOPY,0),    "PKCS11_DIGESTCOPY"},
+    {0,NULL}
+};
+
+static ERR_STRING_DATA pkcs11_str_reasons[]=
+{
+    {PKCS11_R_ALREADY_LOADED                 ,"PKCS#11 DSO already loaded"},
+    {PKCS11_R_DSO_FAILURE                    ,"unable to load PKCS#11 DSO"},
+    {PKCS11_R_NOT_LOADED                     ,"PKCS#11 DSO not loaded"},
+    {PKCS11_R_PASSED_NULL_PARAMETER          ,"null parameter passed"},
+    {PKCS11_R_COMMAND_NOT_IMPLEMENTED        ,"command not implemented"},
+    {PKCS11_R_INITIALIZE                     ,"C_Initialize failed"},
+    {PKCS11_R_FINALIZE                       ,"C_Finalize failed"},
+    {PKCS11_R_GETINFO                        ,"C_GetInfo faile"},
+    {PKCS11_R_GETSLOTLIST                    ,"C_GetSlotList failed"},
+    {PKCS11_R_NO_MODULUS_OR_NO_EXPONENT      ,"no modulus or no exponent"},
+    {PKCS11_R_ATTRIBUT_SENSITIVE_OR_INVALID  ,"attrribute sensitive or invalid	"},
+    {PKCS11_R_GETATTRIBUTVALUE               ,"C_GetAttributeValue failed"},
+    {PKCS11_R_NO_MODULUS                     ,"no modulus"},
+    {PKCS11_R_NO_EXPONENT                    ,"no exponent"},
+    {PKCS11_R_FINDOBJECTSINIT                ,"C_FindObjectsInit failed"},
+    {PKCS11_R_FINDOBJECTS                    ,"C_FindObjects failed"},
+    {PKCS11_R_FINDOBJECTSFINAL               ,"C_FindObjectsFinal failed"},
+    {PKCS11_R_OBJECT_NOT_FOUND               ,"object not found"},
+    {PKCS11_R_CREATEOBJECT                   ,"C_CreateObject failed"},
+    {PKCS11_R_DESTROYOBJECT                  ,"C_DestroyObject failed"},
+    {PKCS11_R_OPENSESSION                    ,"C_OpenSession failed"},
+    {PKCS11_R_CLOSESESSION                   ,"C_CloseSession failed"},
+    {PKCS11_R_ENCRYPTINIT                    ,"C_EncryptInit failed"},
+    {PKCS11_R_ENCRYPT                        ,"C_Encrypt failed"},
+    {PKCS11_R_SIGNINIT                       ,"C_SignInit failed"},
+    {PKCS11_R_SIGN                           ,"C_Sign failed"},
+    {PKCS11_R_DECRYPTINIT                    ,"C_DecryptInit failed"},
+    {PKCS11_R_DECRYPT                        ,"C_Decrypt failed"},
+    {PKCS11_R_VERIFYINIT                     ,"C_VerifyRecover failed"},
+    {PKCS11_R_VERIFY                         ,"C_Verify failed	"},
+    {PKCS11_R_VERIFYRECOVERINIT              ,"C_VerifyRecoverInit failed"},
+    {PKCS11_R_VERIFYRECOVER                  ,"C_VerifyRecover failed"},
+    {PKCS11_R_GEN_KEY                        ,"C_GenerateKeyPair failed"},
+    {PKCS11_R_SEEDRANDOM                     ,"C_SeedRandom failed"},
+    {PKCS11_R_GENERATERANDOM                 ,"C_GenerateRandom failed"},
+    {PKCS11_R_INVALID_MESSAGE_LENGTH         ,"invalid message length"},
+    {PKCS11_R_UNKNOWN_ALGORITHM_TYPE         ,"unknown algorithm type"},
+    {PKCS11_R_UNKNOWN_ASN1_OBJECT_ID         ,"unknown asn1 onject id"},
+    {PKCS11_R_UNKNOWN_PADDING_TYPE           ,"unknown padding type"},
+    {PKCS11_R_DIGEST_TOO_BIG                 ,"digest too big"},
+    {PKCS11_R_MALLOC_FAILURE                 ,"malloc failure"},
+    {PKCS11_R_CTRL_COMMAND_NOT_IMPLEMENTED   ,"control command not implemented"},
+    {PKCS11_R_GETSLOTINFO		     ,"C_GetSlotInfo failed"},
+    {PKCS11_R_GETMECHANISMLIST		     ,"C_GetMechanismList failed"},
+    {PKCS11_R_GETMECHANISMINFO		     ,"C_GetMechanismInfo failed"},
+    {PKCS11_R_BADMECHANISM		     ,"bad mechanism"},
+    {PKCS11_R_DIGESTINIT		     ,"C_DigestInit failed"},
+    {PKCS11_R_DIGESTUPDATE		     ,"C_DigestUpdate failed"},
+    {PKCS11_R_DIGESTFINAL		     ,"C_DigestFinal failed"},
+    {PKCS11_R_NOTOKENS			     ,"no hardware tokens found"},
+    {PKCS11_R_NOTOKENFORALGORITHM	     ,"no tokens available to accelerate algorithm"},
+    {PKCS11_R_DIGEST			     ,"C_Digest failed"},
+    {0,NULL}
+};
+
+#endif	
+
+static int pkcs11_lib_error_code=0;
+static int pkcs11_error_init=1;
+
+static void ERR_load_pkcs11_strings(void)
+{
+    if (pkcs11_lib_error_code == 0)
+	pkcs11_lib_error_code = ERR_get_next_error_library();
+
+    if (pkcs11_error_init)
+    {
+	pkcs11_error_init=0;
+#ifndef OPENSSL_NO_ERR
+	ERR_load_strings(pkcs11_lib_error_code,pkcs11_str_functs);
+	ERR_load_strings(pkcs11_lib_error_code,pkcs11_str_reasons);
+#endif
+    }
+}
+
+static void ERR_unload_pkcs11_strings(void)
+{
+    if (pkcs11_error_init == 0)
+    {
+#ifndef OPENSSL_NO_ERR
+	ERR_unload_strings(pkcs11_lib_error_code,pkcs11_str_functs);
+	ERR_unload_strings(pkcs11_lib_error_code,pkcs11_str_reasons);
+#endif
+	pkcs11_error_init = 1;
+    }
+}
+
+static void ERR_pkcs11_error(int function, int reason, char *file, int line)
+{
+    if (pkcs11_lib_error_code == 0)
+	pkcs11_lib_error_code=ERR_get_next_error_library();
+    ERR_PUT_error(pkcs11_lib_error_code,function,reason,file,line);
+    //ERR_print_errors_fp(stderr);
+}
diff -urN openssl-0.9.8e/engines/e_pkcs11_err.h openssl-0.9.8e.new/engines/e_pkcs11_err.h
--- openssl-0.9.8e/engines/e_pkcs11_err.h	1970-01-01 10:00:00.000000000 +1000
+++ openssl-0.9.8e.new/engines/e_pkcs11_err.h	2008-06-13 09:45:21.000000000 +1000
@@ -0,0 +1,103 @@
+/* hw_pkcs11_err.h (replace hw_trustway.c) */
+/*
+ * PKCS#11 engine for the OpenSSL project 2002
+ * Developped by Bull Trustway R&D Networking & Security
+ * Introduced and tested with Bull TrustWay CC2000 crypto hardware
+ * Afchine.Madjlessi@bull.net Bull S.A. France
+ * http://www.servers.bull.com/trustway
+ */
+
+#ifndef HEADER_PKCS11_ERR_H
+#define HEADER_PKCS11_ERR_H
+
+static void ERR_load_pkcs11_strings(void);
+static void ERR_pkcs11_error(int function, int reason, char *file, int line);
+#define PKCS11err(f,r) ERR_pkcs11_error((f),(r),__FILE__,__LINE__)
+
+/* Error codes for the PKCS11 functions. */
+
+/* Function codes. */
+
+#define PKCS11_F_INIT 100
+#define PKCS11_F_FINISH 101
+#define PKCS11_F_DESTROY 102
+#define PKCS11_F_CTRL 103
+#define PKCS11_F_RSA_INIT 104
+#define PKCS11_F_RSA_FINISH 105
+#define PKCS11_F_FINDORCREATEKEY 106
+#define PKCS11_F_RSA_GEN_KEY 107
+#define PKCS11_F_RSA_PUB_ENC 108
+#define PKCS11_F_RSA_PRIV_ENC 109
+#define PKCS11_F_RSA_PUB_DEC 110
+#define PKCS11_F_RSA_PRIV_DEC 111
+#define PKCS11_F_RSA_SIGN 112
+#define PKCS11_F_RSA_VERIFY 113
+#define PKCS11_F_RAND_ADD 114
+#define PKCS11_F_RAND_BYTES 115
+#define PKCS11_F_GETSESSION 116
+#define PKCS11_F_FREESESSION 117
+#define PKCS11_F_LOAD_PUBKEY 118
+#define PKCS11_F_LOAD_PRIVKEY 119
+#define PKCS11_F_ADDTOKEN 120
+#define PKCS11_F_INITKEY 121
+#define PKCS11_F_DIGESTINIT 122
+#define PKCS11_F_DIGESTUPDATE 123
+#define PKCS11_F_DIGESTFINISH 124
+#define PKCS11_F_CIPHER_UPDATE 125
+#define PKCS11_F_PREINIT 126
+#define PKCS11_F_DIGESTCOPY 127
+
+/* Reason codes. */
+#define PKCS11_R_ALREADY_LOADED 100
+#define PKCS11_R_DSO_FAILURE 101
+#define PKCS11_R_NOT_LOADED 102
+#define PKCS11_R_PASSED_NULL_PARAMETER 103
+#define PKCS11_R_COMMAND_NOT_IMPLEMENTED 104
+#define PKCS11_R_INITIALIZE 105
+#define PKCS11_R_FINALIZE 106
+#define PKCS11_R_GETINFO 107
+#define PKCS11_R_GETSLOTLIST 108
+#define PKCS11_R_NO_MODULUS_OR_NO_EXPONENT 109
+#define PKCS11_R_ATTRIBUT_SENSITIVE_OR_INVALID 110
+#define PKCS11_R_GETATTRIBUTVALUE 111
+#define PKCS11_R_NO_MODULUS 112
+#define PKCS11_R_NO_EXPONENT 113
+#define PKCS11_R_FINDOBJECTSINIT 114
+#define PKCS11_R_FINDOBJECTS 115
+#define PKCS11_R_FINDOBJECTSFINAL 116
+#define PKCS11_R_OBJECT_NOT_FOUND 117
+#define PKCS11_R_CREATEOBJECT 118
+#define PKCS11_R_DESTROYOBJECT 119
+#define PKCS11_R_OPENSESSION 120
+#define PKCS11_R_CLOSESESSION 121
+#define PKCS11_R_ENCRYPTINIT 122
+#define PKCS11_R_ENCRYPT 123
+#define PKCS11_R_SIGNINIT 124
+#define PKCS11_R_SIGN 125
+#define PKCS11_R_DECRYPTINIT 126
+#define PKCS11_R_DECRYPT 127
+#define PKCS11_R_VERIFYINIT 128
+#define PKCS11_R_VERIFY 129
+#define PKCS11_R_VERIFYRECOVERINIT 130
+#define PKCS11_R_VERIFYRECOVER 131
+#define PKCS11_R_GEN_KEY 132
+#define PKCS11_R_SEEDRANDOM 133
+#define PKCS11_R_GENERATERANDOM 134
+#define PKCS11_R_INVALID_MESSAGE_LENGTH 135
+#define PKCS11_R_UNKNOWN_ALGORITHM_TYPE 136
+#define PKCS11_R_UNKNOWN_ASN1_OBJECT_ID 137
+#define PKCS11_R_UNKNOWN_PADDING_TYPE 138
+#define PKCS11_R_DIGEST_TOO_BIG 139
+#define PKCS11_R_MALLOC_FAILURE 140
+#define PKCS11_R_CTRL_COMMAND_NOT_IMPLEMENTED 141
+#define PKCS11_R_GETSLOTINFO 142
+#define PKCS11_R_GETMECHANISMLIST 143
+#define PKCS11_R_GETMECHANISMINFO 144
+#define PKCS11_R_BADMECHANISM 145
+#define PKCS11_R_DIGESTINIT 146
+#define PKCS11_R_DIGESTUPDATE 147
+#define PKCS11_R_DIGESTFINAL 148
+#define PKCS11_R_NOTOKENS 149
+#define PKCS11_R_NOTOKENFORALGORITHM 150
+#define PKCS11_R_DIGEST 151
+#endif
diff -urN openssl-0.9.8e/engines/e_pkcs11.h openssl-0.9.8e.new/engines/e_pkcs11.h
--- openssl-0.9.8e/engines/e_pkcs11.h	1970-01-01 10:00:00.000000000 +1000
+++ openssl-0.9.8e.new/engines/e_pkcs11.h	2008-06-13 09:45:21.000000000 +1000
@@ -0,0 +1,33 @@
+
+#ifndef _HW_PKCS11_H_
+#define _HW_PKCS11_H_
+
+
+
+
+struct _token {
+	struct _token *token_next;	/* next token in list of all tokens */
+	CK_SLOT_ID slot;		/* slot ID of this token */
+};
+
+/* Future:
+ *   Lists for free (non-busy) rsa,des... tokens.
+ */
+
+struct _token *pkcs11_token_list = NULL;
+
+struct _token *pkcs11_rsa_head = NULL;
+struct _token *pkcs11_des_head = NULL;
+struct _token *pkcs11_tdes_head = NULL;
+struct _token *pkcs11_sha_head = NULL;
+struct _token *pkcs11_dh_head = NULL;
+struct _token *pkcs11_aes_head = NULL;
+struct _token *pkcs11_ripemd_head = NULL;
+struct _token *pkcs11_ssl3_head = NULL;
+struct _token *pkcs11_md5_head = NULL;
+
+enum alg_type { alg_rsa=1, alg_des, alg_tdes, alg_sha, alg_dh, alg_aes,
+		alg_ripemd, alg_ssl3, alg_md5, alg_rand,
+		alg_sha224,alg_sha256,alg_sha384,alg_sha512 };
+
+#endif
diff -urN openssl-0.9.8e/engines/Makefile openssl-0.9.8e.new/engines/Makefile
--- openssl-0.9.8e/engines/Makefile	2006-02-04 11:49:34.000000000 +1000
+++ openssl-0.9.8e.new/engines/Makefile	2008-06-13 10:35:39.000000000 +1000
@@ -10,7 +10,7 @@
 MAKEFILE=	Makefile
 AR=		ar r
 
-PEX_LIBS=
+PEX_LIBS=-ldl -lpthread
 EX_LIBS=
 
 CFLAGS= $(INCLUDES) $(CFLAG)
@@ -20,7 +20,7 @@
 APPS=
 
 LIB=$(TOP)/libcrypto.a
-LIBNAMES= 4758cca aep atalla cswift gmp chil nuron sureware ubsec
+LIBNAMES= 4758cca aep atalla cswift gmp chil nuron sureware ubsec pkcs11
 
 LIBSRC=	e_4758cca.c \
 	e_aep.c \
@@ -30,7 +30,8 @@
 	e_chil.c \
 	e_nuron.c \
 	e_sureware.c \
-	e_ubsec.c
+	e_ubsec.c \
+	e_pkcs11.c
 LIBOBJ= e_4758cca.o \
 	e_aep.o \
 	e_atalla.o \
@@ -39,7 +40,8 @@
 	e_chil.o \
 	e_nuron.o \
 	e_sureware.o \
-	e_ubsec.o
+	e_ubsec.o\
+	e_pkcs11.o
 
 SRC= $(LIBSRC)
 
@@ -52,7 +54,8 @@
 	e_chil_err.c e_chil_err.h \
 	e_nuron_err.c e_nuron_err.h \
 	e_sureware_err.c e_sureware_err.h \
-	e_ubsec_err.c e_ubsec_err.h
+	e_ubsec_err.c e_ubsec_err.h \
+	e_pkcs11.c e_pkcs11.h
 
 ALL=    $(GENERAL) $(SRC) $(HEADER)
 
diff -urN openssl-0.9.8e/engines/pkcs11ext.h openssl-0.9.8e.new/engines/pkcs11ext.h
--- openssl-0.9.8e/engines/pkcs11ext.h	1970-01-01 10:00:00.000000000 +1000
+++ openssl-0.9.8e.new/engines/pkcs11ext.h	2008-06-13 09:45:21.000000000 +1000
@@ -0,0 +1,11 @@
+#ifndef PKCS11EXT_H
+#define PKCS11EXT_H
+
+#define CKM_TLS1_PRE_MASTER_KEY_GEN 	 CKM_VENDOR_DEFINED+CKM_SSL3_PRE_MASTER_KEY_GEN
+#define CKM_TLS1_MASTER_KEY_DERIVE  	 CKM_VENDOR_DEFINED+CKM_SSL3_MASTER_KEY_DERIVE 
+#define CKM_TLS1_KEY_AND_MAC_DERIVE 	 CKM_VENDOR_DEFINED+CKM_SSL3_KEY_AND_MAC_DERIVE
+#define CKM_TLS1_MD5_MAC            	 CKM_VENDOR_DEFINED+CKM_SSL3_MD5_MAC           
+#define CKM_TLS1_SHA1_MAC           	 CKM_VENDOR_DEFINED+CKM_SSL3_SHA1_MAC          
+#define CKM_RSA_PKCS_KEY_PAIR_GEN_POOL   CKM_VENDOR_DEFINED+CKM_RSA_PKCS_KEY_PAIR_GEN
+
+#endif
diff -urN openssl-0.9.8e/engines/pkcs11f.h openssl-0.9.8e.new/engines/pkcs11f.h
--- openssl-0.9.8e/engines/pkcs11f.h	1970-01-01 10:00:00.000000000 +1000
+++ openssl-0.9.8e.new/engines/pkcs11f.h	2008-06-13 09:45:21.000000000 +1000
@@ -0,0 +1,912 @@
+/* pkcs11f.h include file for PKCS #11. */
+/* $Revision: 1.1 $ */
+
+/* License to copy and use this software is granted provided that it is
+ * identified as "RSA Security Inc. PKCS #11 Cryptographic Token Interface
+ * (Cryptoki)" in all material mentioning or referencing this software.
+
+ * License is also granted to make and use derivative works provided that
+ * such works are identified as "derived from the RSA Security Inc. PKCS #11
+ * Cryptographic Token Interface (Cryptoki)" in all material mentioning or 
+ * referencing the derived work.
+
+ * RSA Security Inc. makes no representations concerning either the 
+ * merchantability of this software or the suitability of this software for
+ * any particular purpose. It is provided "as is" without express or implied
+ * warranty of any kind.
+ */
+
+/* This header file contains pretty much everything about all the */
+/* Cryptoki function prototypes.  Because this information is */
+/* used for more than just declaring function prototypes, the */
+/* order of the functions appearing herein is important, and */
+/* should not be altered. */
+
+/* General-purpose */
+
+/* C_Initialize initializes the Cryptoki library. */
+CK_PKCS11_FUNCTION_INFO(C_Initialize)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_VOID_PTR   pInitArgs  /* if this is not NULL_PTR, it gets
+                            * cast to CK_C_INITIALIZE_ARGS_PTR
+                            * and dereferenced */
+);
+#endif
+
+
+/* C_Finalize indicates that an application is done with the
+ * Cryptoki library. */
+CK_PKCS11_FUNCTION_INFO(C_Finalize)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_VOID_PTR   pReserved  /* reserved.  Should be NULL_PTR */
+);
+#endif
+
+
+/* C_GetInfo returns general information about Cryptoki. */
+CK_PKCS11_FUNCTION_INFO(C_GetInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_INFO_PTR   pInfo  /* location that receives information */
+);
+#endif
+
+
+/* C_GetFunctionList returns the function list. */
+CK_PKCS11_FUNCTION_INFO(C_GetFunctionList)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_FUNCTION_LIST_PTR_PTR ppFunctionList  /* receives pointer to
+                                            * function list */
+);
+#endif
+
+
+
+/* Slot and token management */
+
+/* C_GetSlotList obtains a list of slots in the system. */
+CK_PKCS11_FUNCTION_INFO(C_GetSlotList)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_BBOOL       tokenPresent,  /* only slots with tokens? */
+  CK_SLOT_ID_PTR pSlotList,     /* receives array of slot IDs */
+  CK_ULONG_PTR   pulCount       /* receives number of slots */
+);
+#endif
+
+
+/* C_GetSlotInfo obtains information about a particular slot in
+ * the system. */
+CK_PKCS11_FUNCTION_INFO(C_GetSlotInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID       slotID,  /* the ID of the slot */
+  CK_SLOT_INFO_PTR pInfo    /* receives the slot information */
+);
+#endif
+
+
+/* C_GetTokenInfo obtains information about a particular token
+ * in the system. */
+CK_PKCS11_FUNCTION_INFO(C_GetTokenInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID        slotID,  /* ID of the token's slot */
+  CK_TOKEN_INFO_PTR pInfo    /* receives the token information */
+);
+#endif
+
+
+/* C_GetMechanismList obtains a list of mechanism types
+ * supported by a token. */
+CK_PKCS11_FUNCTION_INFO(C_GetMechanismList)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID            slotID,          /* ID of token's slot */
+  CK_MECHANISM_TYPE_PTR pMechanismList,  /* gets mech. array */
+  CK_ULONG_PTR          pulCount         /* gets # of mechs. */
+);
+#endif
+
+
+/* C_GetMechanismInfo obtains information about a particular
+ * mechanism possibly supported by a token. */
+CK_PKCS11_FUNCTION_INFO(C_GetMechanismInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID            slotID,  /* ID of the token's slot */
+  CK_MECHANISM_TYPE     type,    /* type of mechanism */
+  CK_MECHANISM_INFO_PTR pInfo    /* receives mechanism info */
+);
+#endif
+
+
+/* C_InitToken initializes a token. */
+CK_PKCS11_FUNCTION_INFO(C_InitToken)
+#ifdef CK_NEED_ARG_LIST
+/* pLabel changed from CK_CHAR_PTR to CK_UTF8CHAR_PTR for v2.10 */
+(
+  CK_SLOT_ID      slotID,    /* ID of the token's slot */
+  CK_UTF8CHAR_PTR pPin,      /* the SO's initial PIN */
+  CK_ULONG        ulPinLen,  /* length in bytes of the PIN */
+  CK_UTF8CHAR_PTR pLabel     /* 32-byte token label (blank padded) */
+);
+#endif
+
+
+/* C_InitPIN initializes the normal user's PIN. */
+CK_PKCS11_FUNCTION_INFO(C_InitPIN)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_UTF8CHAR_PTR   pPin,      /* the normal user's PIN */
+  CK_ULONG          ulPinLen   /* length in bytes of the PIN */
+);
+#endif
+
+
+/* C_SetPIN modifies the PIN of the user who is logged in. */
+CK_PKCS11_FUNCTION_INFO(C_SetPIN)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_UTF8CHAR_PTR   pOldPin,   /* the old PIN */
+  CK_ULONG          ulOldLen,  /* length of the old PIN */
+  CK_UTF8CHAR_PTR   pNewPin,   /* the new PIN */
+  CK_ULONG          ulNewLen   /* length of the new PIN */
+);
+#endif
+
+
+
+/* Session management */
+
+/* C_OpenSession opens a session between an application and a
+ * token. */
+CK_PKCS11_FUNCTION_INFO(C_OpenSession)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID            slotID,        /* the slot's ID */
+  CK_FLAGS              flags,         /* from CK_SESSION_INFO */
+  CK_VOID_PTR           pApplication,  /* passed to callback */
+  CK_NOTIFY             Notify,        /* callback function */
+  CK_SESSION_HANDLE_PTR phSession      /* gets session handle */
+);
+#endif
+
+
+/* C_CloseSession closes a session between an application and a
+ * token. */
+CK_PKCS11_FUNCTION_INFO(C_CloseSession)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+/* C_CloseAllSessions closes all sessions with a token. */
+CK_PKCS11_FUNCTION_INFO(C_CloseAllSessions)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID     slotID  /* the token's slot */
+);
+#endif
+
+
+/* C_GetSessionInfo obtains information about the session. */
+CK_PKCS11_FUNCTION_INFO(C_GetSessionInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE   hSession,  /* the session's handle */
+  CK_SESSION_INFO_PTR pInfo      /* receives session info */
+);
+#endif
+
+
+/* C_GetOperationState obtains the state of the cryptographic operation
+ * in a session. */
+CK_PKCS11_FUNCTION_INFO(C_GetOperationState)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,             /* session's handle */
+  CK_BYTE_PTR       pOperationState,      /* gets state */
+  CK_ULONG_PTR      pulOperationStateLen  /* gets state length */
+);
+#endif
+
+
+/* C_SetOperationState restores the state of the cryptographic
+ * operation in a session. */
+CK_PKCS11_FUNCTION_INFO(C_SetOperationState)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR      pOperationState,      /* holds state */
+  CK_ULONG         ulOperationStateLen,  /* holds state length */
+  CK_OBJECT_HANDLE hEncryptionKey,       /* en/decryption key */
+  CK_OBJECT_HANDLE hAuthenticationKey    /* sign/verify key */
+);
+#endif
+
+
+/* C_Login logs a user into a token. */
+CK_PKCS11_FUNCTION_INFO(C_Login)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_USER_TYPE      userType,  /* the user type */
+  CK_UTF8CHAR_PTR   pPin,      /* the user's PIN */
+  CK_ULONG          ulPinLen   /* the length of the PIN */
+);
+#endif
+
+
+/* C_Logout logs a user out from a token. */
+CK_PKCS11_FUNCTION_INFO(C_Logout)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+
+/* Object management */
+
+/* C_CreateObject creates a new object. */
+CK_PKCS11_FUNCTION_INFO(C_CreateObject)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_ATTRIBUTE_PTR  pTemplate,   /* the object's template */
+  CK_ULONG          ulCount,     /* attributes in template */
+  CK_OBJECT_HANDLE_PTR phObject  /* gets new object's handle. */
+);
+#endif
+
+
+/* C_CopyObject copies an object, creating a new object for the
+ * copy. */
+CK_PKCS11_FUNCTION_INFO(C_CopyObject)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,    /* the session's handle */
+  CK_OBJECT_HANDLE     hObject,     /* the object's handle */
+  CK_ATTRIBUTE_PTR     pTemplate,   /* template for new object */
+  CK_ULONG             ulCount,     /* attributes in template */
+  CK_OBJECT_HANDLE_PTR phNewObject  /* receives handle of copy */
+);
+#endif
+
+
+/* C_DestroyObject destroys an object. */
+CK_PKCS11_FUNCTION_INFO(C_DestroyObject)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_OBJECT_HANDLE  hObject    /* the object's handle */
+);
+#endif
+
+
+/* C_GetObjectSize gets the size of an object in bytes. */
+CK_PKCS11_FUNCTION_INFO(C_GetObjectSize)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_OBJECT_HANDLE  hObject,   /* the object's handle */
+  CK_ULONG_PTR      pulSize    /* receives size of object */
+);
+#endif
+
+
+/* C_GetAttributeValue obtains the value of one or more object
+ * attributes. */
+CK_PKCS11_FUNCTION_INFO(C_GetAttributeValue)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_OBJECT_HANDLE  hObject,    /* the object's handle */
+  CK_ATTRIBUTE_PTR  pTemplate,  /* specifies attrs; gets vals */
+  CK_ULONG          ulCount     /* attributes in template */
+);
+#endif
+
+
+/* C_SetAttributeValue modifies the value of one or more object
+ * attributes */
+CK_PKCS11_FUNCTION_INFO(C_SetAttributeValue)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_OBJECT_HANDLE  hObject,    /* the object's handle */
+  CK_ATTRIBUTE_PTR  pTemplate,  /* specifies attrs and values */
+  CK_ULONG          ulCount     /* attributes in template */
+);
+#endif
+
+
+/* C_FindObjectsInit initializes a search for token and session
+ * objects that match a template. */
+CK_PKCS11_FUNCTION_INFO(C_FindObjectsInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_ATTRIBUTE_PTR  pTemplate,  /* attribute values to match */
+  CK_ULONG          ulCount     /* attrs in search template */
+);
+#endif
+
+
+/* C_FindObjects continues a search for token and session
+ * objects that match a template, obtaining additional object
+ * handles. */
+CK_PKCS11_FUNCTION_INFO(C_FindObjects)
+#ifdef CK_NEED_ARG_LIST
+(
+ CK_SESSION_HANDLE    hSession,          /* session's handle */
+ CK_OBJECT_HANDLE_PTR phObject,          /* gets obj. handles */
+ CK_ULONG             ulMaxObjectCount,  /* max handles to get */
+ CK_ULONG_PTR         pulObjectCount     /* actual # returned */
+);
+#endif
+
+
+/* C_FindObjectsFinal finishes a search for token and session
+ * objects. */
+CK_PKCS11_FUNCTION_INFO(C_FindObjectsFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+
+/* Encryption and decryption */
+
+/* C_EncryptInit initializes an encryption operation. */
+CK_PKCS11_FUNCTION_INFO(C_EncryptInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the encryption mechanism */
+  CK_OBJECT_HANDLE  hKey         /* handle of encryption key */
+);
+#endif
+
+
+/* C_Encrypt encrypts single-part data. */
+CK_PKCS11_FUNCTION_INFO(C_Encrypt)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pData,               /* the plaintext data */
+  CK_ULONG          ulDataLen,           /* bytes of plaintext */
+  CK_BYTE_PTR       pEncryptedData,      /* gets ciphertext */
+  CK_ULONG_PTR      pulEncryptedDataLen  /* gets c-text size */
+);
+#endif
+
+
+/* C_EncryptUpdate continues a multiple-part encryption
+ * operation. */
+CK_PKCS11_FUNCTION_INFO(C_EncryptUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,           /* session's handle */
+  CK_BYTE_PTR       pPart,              /* the plaintext data */
+  CK_ULONG          ulPartLen,          /* plaintext data len */
+  CK_BYTE_PTR       pEncryptedPart,     /* gets ciphertext */
+  CK_ULONG_PTR      pulEncryptedPartLen /* gets c-text size */
+);
+#endif
+
+
+/* C_EncryptFinal finishes a multiple-part encryption
+ * operation. */
+CK_PKCS11_FUNCTION_INFO(C_EncryptFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,                /* session handle */
+  CK_BYTE_PTR       pLastEncryptedPart,      /* last c-text */
+  CK_ULONG_PTR      pulLastEncryptedPartLen  /* gets last size */
+);
+#endif
+
+
+/* C_DecryptInit initializes a decryption operation. */
+CK_PKCS11_FUNCTION_INFO(C_DecryptInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the decryption mechanism */
+  CK_OBJECT_HANDLE  hKey         /* handle of decryption key */
+);
+#endif
+
+
+/* C_Decrypt decrypts encrypted data in a single part. */
+CK_PKCS11_FUNCTION_INFO(C_Decrypt)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,           /* session's handle */
+  CK_BYTE_PTR       pEncryptedData,     /* ciphertext */
+  CK_ULONG          ulEncryptedDataLen, /* ciphertext length */
+  CK_BYTE_PTR       pData,              /* gets plaintext */
+  CK_ULONG_PTR      pulDataLen          /* gets p-text size */
+);
+#endif
+
+
+/* C_DecryptUpdate continues a multiple-part decryption
+ * operation. */
+CK_PKCS11_FUNCTION_INFO(C_DecryptUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pEncryptedPart,      /* encrypted data */
+  CK_ULONG          ulEncryptedPartLen,  /* input length */
+  CK_BYTE_PTR       pPart,               /* gets plaintext */
+  CK_ULONG_PTR      pulPartLen           /* p-text size */
+);
+#endif
+
+
+/* C_DecryptFinal finishes a multiple-part decryption
+ * operation. */
+CK_PKCS11_FUNCTION_INFO(C_DecryptFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,       /* the session's handle */
+  CK_BYTE_PTR       pLastPart,      /* gets plaintext */
+  CK_ULONG_PTR      pulLastPartLen  /* p-text size */
+);
+#endif
+
+
+
+/* Message digesting */
+
+/* C_DigestInit initializes a message-digesting operation. */
+CK_PKCS11_FUNCTION_INFO(C_DigestInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism  /* the digesting mechanism */
+);
+#endif
+
+
+/* C_Digest digests data in a single part. */
+CK_PKCS11_FUNCTION_INFO(C_Digest)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,     /* the session's handle */
+  CK_BYTE_PTR       pData,        /* data to be digested */
+  CK_ULONG          ulDataLen,    /* bytes of data to digest */
+  CK_BYTE_PTR       pDigest,      /* gets the message digest */
+  CK_ULONG_PTR      pulDigestLen  /* gets digest length */
+);
+#endif
+
+
+/* C_DigestUpdate continues a multiple-part message-digesting
+ * operation. */
+CK_PKCS11_FUNCTION_INFO(C_DigestUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_BYTE_PTR       pPart,     /* data to be digested */
+  CK_ULONG          ulPartLen  /* bytes of data to be digested */
+);
+#endif
+
+
+/* C_DigestKey continues a multi-part message-digesting
+ * operation, by digesting the value of a secret key as part of
+ * the data already digested. */
+CK_PKCS11_FUNCTION_INFO(C_DigestKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_OBJECT_HANDLE  hKey       /* secret key to digest */
+);
+#endif
+
+
+/* C_DigestFinal finishes a multiple-part message-digesting
+ * operation. */
+CK_PKCS11_FUNCTION_INFO(C_DigestFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,     /* the session's handle */
+  CK_BYTE_PTR       pDigest,      /* gets the message digest */
+  CK_ULONG_PTR      pulDigestLen  /* gets byte count of digest */
+);
+#endif
+
+
+
+/* Signing and MACing */
+
+/* C_SignInit initializes a signature (private key encryption)
+ * operation, where the signature is (will be) an appendix to
+ * the data, and plaintext cannot be recovered from the
+ *signature. */
+CK_PKCS11_FUNCTION_INFO(C_SignInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the signature mechanism */
+  CK_OBJECT_HANDLE  hKey         /* handle of signature key */
+);
+#endif
+
+
+/* C_Sign signs (encrypts with private key) data in a single
+ * part, where the signature is (will be) an appendix to the
+ * data, and plaintext cannot be recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_Sign)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_BYTE_PTR       pData,           /* the data to sign */
+  CK_ULONG          ulDataLen,       /* count of bytes to sign */
+  CK_BYTE_PTR       pSignature,      /* gets the signature */
+  CK_ULONG_PTR      pulSignatureLen  /* gets signature length */
+);
+#endif
+
+
+/* C_SignUpdate continues a multiple-part signature operation,
+ * where the signature is (will be) an appendix to the data, 
+ * and plaintext cannot be recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_SignUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_BYTE_PTR       pPart,     /* the data to sign */
+  CK_ULONG          ulPartLen  /* count of bytes to sign */
+);
+#endif
+
+
+/* C_SignFinal finishes a multiple-part signature operation, 
+ * returning the signature. */
+CK_PKCS11_FUNCTION_INFO(C_SignFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_BYTE_PTR       pSignature,      /* gets the signature */
+  CK_ULONG_PTR      pulSignatureLen  /* gets signature length */
+);
+#endif
+
+
+/* C_SignRecoverInit initializes a signature operation, where
+ * the data can be recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_SignRecoverInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism, /* the signature mechanism */
+  CK_OBJECT_HANDLE  hKey        /* handle of the signature key */
+);
+#endif
+
+
+/* C_SignRecover signs data in a single operation, where the
+ * data can be recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_SignRecover)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_BYTE_PTR       pData,           /* the data to sign */
+  CK_ULONG          ulDataLen,       /* count of bytes to sign */
+  CK_BYTE_PTR       pSignature,      /* gets the signature */
+  CK_ULONG_PTR      pulSignatureLen  /* gets signature length */
+);
+#endif
+
+
+
+/* Verifying signatures and MACs */
+
+/* C_VerifyInit initializes a verification operation, where the
+ * signature is an appendix to the data, and plaintext cannot
+ *  cannot be recovered from the signature (e.g. DSA). */
+CK_PKCS11_FUNCTION_INFO(C_VerifyInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the verification mechanism */
+  CK_OBJECT_HANDLE  hKey         /* verification key */ 
+);
+#endif
+
+
+/* C_Verify verifies a signature in a single-part operation, 
+ * where the signature is an appendix to the data, and plaintext
+ * cannot be recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_Verify)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,       /* the session's handle */
+  CK_BYTE_PTR       pData,          /* signed data */
+  CK_ULONG          ulDataLen,      /* length of signed data */
+  CK_BYTE_PTR       pSignature,     /* signature */
+  CK_ULONG          ulSignatureLen  /* signature length*/
+);
+#endif
+
+
+/* C_VerifyUpdate continues a multiple-part verification
+ * operation, where the signature is an appendix to the data, 
+ * and plaintext cannot be recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_VerifyUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_BYTE_PTR       pPart,     /* signed data */
+  CK_ULONG          ulPartLen  /* length of signed data */
+);
+#endif
+
+
+/* C_VerifyFinal finishes a multiple-part verification
+ * operation, checking the signature. */
+CK_PKCS11_FUNCTION_INFO(C_VerifyFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,       /* the session's handle */
+  CK_BYTE_PTR       pSignature,     /* signature to verify */
+  CK_ULONG          ulSignatureLen  /* signature length */
+);
+#endif
+
+
+/* C_VerifyRecoverInit initializes a signature verification
+ * operation, where the data is recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_VerifyRecoverInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the verification mechanism */
+  CK_OBJECT_HANDLE  hKey         /* verification key */
+);
+#endif
+
+
+/* C_VerifyRecover verifies a signature in a single-part
+ * operation, where the data is recovered from the signature. */
+CK_PKCS11_FUNCTION_INFO(C_VerifyRecover)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_BYTE_PTR       pSignature,      /* signature to verify */
+  CK_ULONG          ulSignatureLen,  /* signature length */
+  CK_BYTE_PTR       pData,           /* gets signed data */
+  CK_ULONG_PTR      pulDataLen       /* gets signed data len */
+);
+#endif
+
+
+
+/* Dual-function cryptographic operations */
+
+/* C_DigestEncryptUpdate continues a multiple-part digesting
+ * and encryption operation. */
+CK_PKCS11_FUNCTION_INFO(C_DigestEncryptUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pPart,               /* the plaintext data */
+  CK_ULONG          ulPartLen,           /* plaintext length */
+  CK_BYTE_PTR       pEncryptedPart,      /* gets ciphertext */
+  CK_ULONG_PTR      pulEncryptedPartLen  /* gets c-text length */
+);
+#endif
+
+
+/* C_DecryptDigestUpdate continues a multiple-part decryption and
+ * digesting operation. */
+CK_PKCS11_FUNCTION_INFO(C_DecryptDigestUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pEncryptedPart,      /* ciphertext */
+  CK_ULONG          ulEncryptedPartLen,  /* ciphertext length */
+  CK_BYTE_PTR       pPart,               /* gets plaintext */
+  CK_ULONG_PTR      pulPartLen           /* gets plaintext len */
+);
+#endif
+
+
+/* C_SignEncryptUpdate continues a multiple-part signing and
+ * encryption operation. */
+CK_PKCS11_FUNCTION_INFO(C_SignEncryptUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pPart,               /* the plaintext data */
+  CK_ULONG          ulPartLen,           /* plaintext length */
+  CK_BYTE_PTR       pEncryptedPart,      /* gets ciphertext */
+  CK_ULONG_PTR      pulEncryptedPartLen  /* gets c-text length */
+);
+#endif
+
+
+/* C_DecryptVerifyUpdate continues a multiple-part decryption and
+ * verify operation. */
+CK_PKCS11_FUNCTION_INFO(C_DecryptVerifyUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pEncryptedPart,      /* ciphertext */
+  CK_ULONG          ulEncryptedPartLen,  /* ciphertext length */
+  CK_BYTE_PTR       pPart,               /* gets plaintext */
+  CK_ULONG_PTR      pulPartLen           /* gets p-text length */
+);
+#endif
+
+
+
+/* Key management */
+
+/* C_GenerateKey generates a secret key, creating a new key
+ * object. */
+CK_PKCS11_FUNCTION_INFO(C_GenerateKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,    /* the session's handle */
+  CK_MECHANISM_PTR     pMechanism,  /* key generation mech. */
+  CK_ATTRIBUTE_PTR     pTemplate,   /* template for new key */
+  CK_ULONG             ulCount,     /* # of attrs in template */
+  CK_OBJECT_HANDLE_PTR phKey        /* gets handle of new key */
+);
+#endif
+
+
+/* C_GenerateKeyPair generates a public-key/private-key pair, 
+ * creating new key objects. */
+CK_PKCS11_FUNCTION_INFO(C_GenerateKeyPair)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,                    /* session
+                                                     * handle */
+  CK_MECHANISM_PTR     pMechanism,                  /* key-gen
+                                                     * mech. */
+  CK_ATTRIBUTE_PTR     pPublicKeyTemplate,          /* template
+                                                     * for pub.
+                                                     * key */
+  CK_ULONG             ulPublicKeyAttributeCount,   /* # pub.
+                                                     * attrs. */
+  CK_ATTRIBUTE_PTR     pPrivateKeyTemplate,         /* template
+                                                     * for priv.
+                                                     * key */
+  CK_ULONG             ulPrivateKeyAttributeCount,  /* # priv.
+                                                     * attrs. */
+  CK_OBJECT_HANDLE_PTR phPublicKey,                 /* gets pub.
+                                                     * key
+                                                     * handle */
+  CK_OBJECT_HANDLE_PTR phPrivateKey                 /* gets
+                                                     * priv. key
+                                                     * handle */
+);
+#endif
+
+
+/* C_WrapKey wraps (i.e., encrypts) a key. */
+CK_PKCS11_FUNCTION_INFO(C_WrapKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,      /* the wrapping mechanism */
+  CK_OBJECT_HANDLE  hWrappingKey,    /* wrapping key */
+  CK_OBJECT_HANDLE  hKey,            /* key to be wrapped */
+  CK_BYTE_PTR       pWrappedKey,     /* gets wrapped key */
+  CK_ULONG_PTR      pulWrappedKeyLen /* gets wrapped key size */
+);
+#endif
+
+
+/* C_UnwrapKey unwraps (decrypts) a wrapped key, creating a new
+ * key object. */
+CK_PKCS11_FUNCTION_INFO(C_UnwrapKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,          /* session's handle */
+  CK_MECHANISM_PTR     pMechanism,        /* unwrapping mech. */
+  CK_OBJECT_HANDLE     hUnwrappingKey,    /* unwrapping key */
+  CK_BYTE_PTR          pWrappedKey,       /* the wrapped key */
+  CK_ULONG             ulWrappedKeyLen,   /* wrapped key len */
+  CK_ATTRIBUTE_PTR     pTemplate,         /* new key template */
+  CK_ULONG             ulAttributeCount,  /* template length */
+  CK_OBJECT_HANDLE_PTR phKey              /* gets new handle */
+);
+#endif
+
+
+/* C_DeriveKey derives a key from a base key, creating a new key
+ * object. */
+CK_PKCS11_FUNCTION_INFO(C_DeriveKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,          /* session's handle */
+  CK_MECHANISM_PTR     pMechanism,        /* key deriv. mech. */
+  CK_OBJECT_HANDLE     hBaseKey,          /* base key */
+  CK_ATTRIBUTE_PTR     pTemplate,         /* new key template */
+  CK_ULONG             ulAttributeCount,  /* template length */
+  CK_OBJECT_HANDLE_PTR phKey              /* gets new handle */
+);
+#endif
+
+
+
+/* Random number generation */
+
+/* C_SeedRandom mixes additional seed material into the token's
+ * random number generator. */
+CK_PKCS11_FUNCTION_INFO(C_SeedRandom)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_BYTE_PTR       pSeed,     /* the seed material */
+  CK_ULONG          ulSeedLen  /* length of seed material */
+);
+#endif
+
+
+/* C_GenerateRandom generates random data. */
+CK_PKCS11_FUNCTION_INFO(C_GenerateRandom)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_BYTE_PTR       RandomData,  /* receives the random data */
+  CK_ULONG          ulRandomLen  /* # of bytes to generate */
+);
+#endif
+
+
+
+/* Parallel function management */
+
+/* C_GetFunctionStatus is a legacy function; it obtains an
+ * updated status of a function running in parallel with an
+ * application. */
+CK_PKCS11_FUNCTION_INFO(C_GetFunctionStatus)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+/* C_CancelFunction is a legacy function; it cancels a function
+ * running in parallel. */
+CK_PKCS11_FUNCTION_INFO(C_CancelFunction)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+
+/* Functions added in for Cryptoki Version 2.01 or later */
+
+/* C_WaitForSlotEvent waits for a slot event (token insertion,
+ * removal, etc.) to occur. */
+CK_PKCS11_FUNCTION_INFO(C_WaitForSlotEvent)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_FLAGS flags,        /* blocking/nonblocking flag */
+  CK_SLOT_ID_PTR pSlot,  /* location that receives the slot ID */
+  CK_VOID_PTR pRserved   /* reserved.  Should be NULL_PTR */
+);
+#endif
diff -urN openssl-0.9.8e/engines/pkcs11.h openssl-0.9.8e.new/engines/pkcs11.h
--- openssl-0.9.8e/engines/pkcs11.h	1970-01-01 10:00:00.000000000 +1000
+++ openssl-0.9.8e.new/engines/pkcs11.h	2008-06-13 09:45:21.000000000 +1000
@@ -0,0 +1,299 @@
+/* pkcs11.h include file for PKCS #11. */
+/* $Revision: 1.1 $ */
+
+/* License to copy and use this software is granted provided that it is
+ * identified as "RSA Security Inc. PKCS #11 Cryptographic Token Interface
+ * (Cryptoki)" in all material mentioning or referencing this software.
+
+ * License is also granted to make and use derivative works provided that
+ * such works are identified as "derived from the RSA Security Inc. PKCS #11
+ * Cryptographic Token Interface (Cryptoki)" in all material mentioning or 
+ * referencing the derived work.
+
+ * RSA Security Inc. makes no representations concerning either the 
+ * merchantability of this software or the suitability of this software for
+ * any particular purpose. It is provided "as is" without express or implied
+ * warranty of any kind.
+ */
+
+#ifndef _PKCS11_H_
+#define _PKCS11_H_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Before including this file (pkcs11.h) (or pkcs11t.h by
+ * itself), 6 platform-specific macros must be defined.  These
+ * macros are described below, and typical definitions for them
+ * are also given.  Be advised that these definitions can depend
+ * on both the platform and the compiler used (and possibly also
+ * on whether a Cryptoki library is linked statically or
+ * dynamically).
+ *
+ * In addition to defining these 6 macros, the packing convention
+ * for Cryptoki structures should be set.  The Cryptoki
+ * convention on packing is that structures should be 1-byte
+ * aligned.
+ *
+ * If you're using Microsoft Developer Studio 5.0 to produce
+ * Win32 stuff, this might be done by using the following
+ * preprocessor directive before including pkcs11.h or pkcs11t.h:
+ *
+ * #pragma pack(push, cryptoki, 1)
+ *
+ * and using the following preprocessor directive after including
+ * pkcs11.h or pkcs11t.h:
+ *
+ * #pragma pack(pop, cryptoki)
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to produce Win16 stuff, this might be done by using
+ * the following preprocessor directive before including
+ * pkcs11.h or pkcs11t.h:
+ *
+ * #pragma pack(1)
+ *
+ * In a UNIX environment, you're on your own for this.  You might
+ * not need to do (or be able to do!) anything.
+ *
+ *
+ * Now for the macros:
+ *
+ *
+ * 1. CK_PTR: The indirection string for making a pointer to an
+ * object.  It can be used like this:
+ *
+ * typedef CK_BYTE CK_PTR CK_BYTE_PTR;
+ *
+ * If you're using Microsoft Developer Studio 5.0 to produce
+ * Win32 stuff, it might be defined by:
+ *
+ * #define CK_PTR *
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to produce Win16 stuff, it might be defined by:
+ *
+ * #define CK_PTR far *
+ *
+ * In a typical UNIX environment, it might be defined by:
+ *
+ * #define CK_PTR *
+ *
+ *
+ * 2. CK_DEFINE_FUNCTION(returnType, name): A macro which makes
+ * an exportable Cryptoki library function definition out of a
+ * return type and a function name.  It should be used in the
+ * following fashion to define the exposed Cryptoki functions in
+ * a Cryptoki library:
+ *
+ * CK_DEFINE_FUNCTION(CK_RV, C_Initialize)(
+ *   CK_VOID_PTR pReserved
+ * )
+ * {
+ *   ...
+ * }
+ *
+ * If you're using Microsoft Developer Studio 5.0 to define a
+ * function in a Win32 Cryptoki .dll, it might be defined by:
+ *
+ * #define CK_DEFINE_FUNCTION(returnType, name) \
+ *   returnType __declspec(dllexport) name
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to define a function in a Win16 Cryptoki .dll, it
+ * might be defined by:
+ *
+ * #define CK_DEFINE_FUNCTION(returnType, name) \
+ *   returnType __export _far _pascal name
+ *
+ * In a UNIX environment, it might be defined by:
+ *
+ * #define CK_DEFINE_FUNCTION(returnType, name) \
+ *   returnType name
+ *
+ *
+ * 3. CK_DECLARE_FUNCTION(returnType, name): A macro which makes
+ * an importable Cryptoki library function declaration out of a
+ * return type and a function name.  It should be used in the
+ * following fashion:
+ *
+ * extern CK_DECLARE_FUNCTION(CK_RV, C_Initialize)(
+ *   CK_VOID_PTR pReserved
+ * );
+ *
+ * If you're using Microsoft Developer Studio 5.0 to declare a
+ * function in a Win32 Cryptoki .dll, it might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION(returnType, name) \
+ *   returnType __declspec(dllimport) name
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to declare a function in a Win16 Cryptoki .dll, it
+ * might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION(returnType, name) \
+ *   returnType __export _far _pascal name
+ *
+ * In a UNIX environment, it might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION(returnType, name) \
+ *   returnType name
+ *
+ *
+ * 4. CK_DECLARE_FUNCTION_POINTER(returnType, name): A macro
+ * which makes a Cryptoki API function pointer declaration or
+ * function pointer type declaration out of a return type and a
+ * function name.  It should be used in the following fashion:
+ *
+ * // Define funcPtr to be a pointer to a Cryptoki API function
+ * // taking arguments args and returning CK_RV.
+ * CK_DECLARE_FUNCTION_POINTER(CK_RV, funcPtr)(args);
+ *
+ * or
+ *
+ * // Define funcPtrType to be the type of a pointer to a
+ * // Cryptoki API function taking arguments args and returning
+ * // CK_RV, and then define funcPtr to be a variable of type
+ * // funcPtrType.
+ * typedef CK_DECLARE_FUNCTION_POINTER(CK_RV, funcPtrType)(args);
+ * funcPtrType funcPtr;
+ *
+ * If you're using Microsoft Developer Studio 5.0 to access
+ * functions in a Win32 Cryptoki .dll, in might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
+ *   returnType __declspec(dllimport) (* name)
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to access functions in a Win16 Cryptoki .dll, it might
+ * be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
+ *   returnType __export _far _pascal (* name)
+ *
+ * In a UNIX environment, it might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
+ *   returnType (* name)
+ *
+ *
+ * 5. CK_CALLBACK_FUNCTION(returnType, name): A macro which makes
+ * a function pointer type for an application callback out of
+ * a return type for the callback and a name for the callback.
+ * It should be used in the following fashion:
+ *
+ * CK_CALLBACK_FUNCTION(CK_RV, myCallback)(args);
+ *
+ * to declare a function pointer, myCallback, to a callback
+ * which takes arguments args and returns a CK_RV.  It can also
+ * be used like this:
+ *
+ * typedef CK_CALLBACK_FUNCTION(CK_RV, myCallbackType)(args);
+ * myCallbackType myCallback;
+ *
+ * If you're using Microsoft Developer Studio 5.0 to do Win32
+ * Cryptoki development, it might be defined by:
+ *
+ * #define CK_CALLBACK_FUNCTION(returnType, name) \
+ *   returnType (* name)
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to do Win16 development, it might be defined by:
+ *
+ * #define CK_CALLBACK_FUNCTION(returnType, name) \
+ *   returnType _far _pascal (* name)
+ *
+ * In a UNIX environment, it might be defined by:
+ *
+ * #define CK_CALLBACK_FUNCTION(returnType, name) \
+ *   returnType (* name)
+ *
+ *
+ * 6. NULL_PTR: This macro is the value of a NULL pointer.
+ *
+ * In any ANSI/ISO C environment (and in many others as well),
+ * this should best be defined by
+ *
+ * #ifndef NULL_PTR
+ * #define NULL_PTR 0
+ * #endif
+ */
+
+
+/* All the various Cryptoki types and #define'd values are in the
+ * file pkcs11t.h. */
+#include "pkcs11t.h"
+
+#define __PASTE(x,y)      x##y
+
+
+/* ==============================================================
+ * Define the "extern" form of all the entry points.
+ * ==============================================================
+ */
+
+#define CK_NEED_ARG_LIST  1
+#define CK_PKCS11_FUNCTION_INFO(name) \
+  extern CK_DECLARE_FUNCTION(CK_RV, name)
+
+/* pkcs11f.h has all the information about the Cryptoki
+ * function prototypes. */
+#include "pkcs11f.h"
+
+#undef CK_NEED_ARG_LIST
+#undef CK_PKCS11_FUNCTION_INFO
+
+
+/* ==============================================================
+ * Define the typedef form of all the entry points.  That is, for
+ * each Cryptoki function C_XXX, define a type CK_C_XXX which is
+ * a pointer to that kind of function.
+ * ==============================================================
+ */
+
+#define CK_NEED_ARG_LIST  1
+#define CK_PKCS11_FUNCTION_INFO(name) \
+  typedef CK_DECLARE_FUNCTION_POINTER(CK_RV, __PASTE(CK_,name))
+
+/* pkcs11f.h has all the information about the Cryptoki
+ * function prototypes. */
+#include "pkcs11f.h"
+
+#undef CK_NEED_ARG_LIST
+#undef CK_PKCS11_FUNCTION_INFO
+
+
+/* ==============================================================
+ * Define structed vector of entry points.  A CK_FUNCTION_LIST
+ * contains a CK_VERSION indicating a library's Cryptoki version
+ * and then a whole slew of function pointers to the routines in
+ * the library.  This type was declared, but not defined, in
+ * pkcs11t.h.
+ * ==============================================================
+ */
+
+#define CK_PKCS11_FUNCTION_INFO(name) \
+  __PASTE(CK_,name) name;
+  
+struct CK_FUNCTION_LIST {
+
+  CK_VERSION    version;  /* Cryptoki version */
+
+/* Pile all the function pointers into the CK_FUNCTION_LIST. */
+/* pkcs11f.h has all the information about the Cryptoki
+ * function prototypes. */
+#include "pkcs11f.h"
+
+};
+
+#undef CK_PKCS11_FUNCTION_INFO
+
+
+#undef __PASTE
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -urN openssl-0.9.8e/engines/pkcs11t.h openssl-0.9.8e.new/engines/pkcs11t.h
--- openssl-0.9.8e/engines/pkcs11t.h	1970-01-01 10:00:00.000000000 +1000
+++ openssl-0.9.8e.new/engines/pkcs11t.h	2008-06-13 09:45:21.000000000 +1000
@@ -0,0 +1,1685 @@
+/* pkcs11t.h include file for PKCS #11. */
+/* $Revision: 1.1 $ */
+
+/* License to copy and use this software is granted provided that it is
+ * identified as "RSA Security Inc. PKCS #11 Cryptographic Token Interface
+ * (Cryptoki)" in all material mentioning or referencing this software.
+
+ * License is also granted to make and use derivative works provided that
+ * such works are identified as "derived from the RSA Security Inc. PKCS #11
+ * Cryptographic Token Interface (Cryptoki)" in all material mentioning or
+ * referencing the derived work.
+
+ * RSA Security Inc. makes no representations concerning either the
+ * merchantability of this software or the suitability of this software for
+ * any particular purpose. It is provided "as is" without express or implied
+ * warranty of any kind.
+ */
+
+/* See top of pkcs11.h for information about the macros that
+ * must be defined and the structure-packing conventions that
+ * must be set before including this file. */
+
+#ifndef _PKCS11T_H_
+#define _PKCS11T_H_ 1
+
+#define CK_TRUE 1
+#define CK_FALSE 0
+
+#ifndef CK_DISABLE_TRUE_FALSE
+#ifndef FALSE
+#define FALSE CK_FALSE
+#endif
+
+#ifndef TRUE
+#define TRUE CK_TRUE
+#endif
+#endif
+
+/* an unsigned 8-bit value */
+typedef unsigned char     CK_BYTE;
+
+/* an unsigned 8-bit character */
+typedef CK_BYTE           CK_CHAR;
+
+/* an 8-bit UTF-8 character */
+typedef CK_BYTE           CK_UTF8CHAR;
+
+/* a BYTE-sized Boolean flag */
+typedef CK_BYTE           CK_BBOOL;
+
+/* an unsigned value, at least 32 bits long */
+typedef unsigned long int CK_ULONG;
+
+/* a signed value, the same size as a CK_ULONG */
+/* CK_LONG is new for v2.0 */
+typedef long int          CK_LONG;
+
+/* at least 32 bits; each bit is a Boolean flag */
+typedef CK_ULONG          CK_FLAGS;
+
+
+/* some special values for certain CK_ULONG variables */
+#define CK_UNAVAILABLE_INFORMATION (~0UL)
+#define CK_EFFECTIVELY_INFINITE    0
+
+
+typedef CK_BYTE     CK_PTR   CK_BYTE_PTR;
+typedef CK_CHAR     CK_PTR   CK_CHAR_PTR;
+typedef CK_UTF8CHAR CK_PTR   CK_UTF8CHAR_PTR;
+typedef CK_ULONG    CK_PTR   CK_ULONG_PTR;
+typedef void        CK_PTR   CK_VOID_PTR;
+
+/* Pointer to a CK_VOID_PTR-- i.e., pointer to pointer to void */
+typedef CK_VOID_PTR CK_PTR CK_VOID_PTR_PTR;
+
+
+/* The following value is always invalid if used as a session */
+/* handle or object handle */
+#define CK_INVALID_HANDLE 0
+
+
+typedef struct CK_VERSION {
+  CK_BYTE       major;  /* integer portion of version number */
+  CK_BYTE       minor;  /* 1/100ths portion of version number */
+} CK_VERSION;
+
+typedef CK_VERSION CK_PTR CK_VERSION_PTR;
+
+
+typedef struct CK_INFO {
+  /* manufacturerID and libraryDecription have been changed from
+   * CK_CHAR to CK_UTF8CHAR for v2.10 */
+  CK_VERSION    cryptokiVersion;     /* Cryptoki interface ver */
+  CK_UTF8CHAR   manufacturerID[32];  /* blank padded */
+  CK_FLAGS      flags;               /* must be zero */
+
+  /* libraryDescription and libraryVersion are new for v2.0 */
+  CK_UTF8CHAR   libraryDescription[32];  /* blank padded */
+  CK_VERSION    libraryVersion;          /* version of library */
+} CK_INFO;
+
+typedef CK_INFO CK_PTR    CK_INFO_PTR;
+
+
+/* CK_NOTIFICATION enumerates the types of notifications that
+ * Cryptoki provides to an application */
+/* CK_NOTIFICATION has been changed from an enum to a CK_ULONG
+ * for v2.0 */
+typedef CK_ULONG CK_NOTIFICATION;
+#define CKN_SURRENDER       0
+
+
+typedef CK_ULONG          CK_SLOT_ID;
+
+typedef CK_SLOT_ID CK_PTR CK_SLOT_ID_PTR;
+
+
+/* CK_SLOT_INFO provides information about a slot */
+typedef struct CK_SLOT_INFO {
+  /* slotDescription and manufacturerID have been changed from
+   * CK_CHAR to CK_UTF8CHAR for v2.10 */
+  CK_UTF8CHAR   slotDescription[64];  /* blank padded */
+  CK_UTF8CHAR   manufacturerID[32];   /* blank padded */
+  CK_FLAGS      flags;
+
+  /* hardwareVersion and firmwareVersion are new for v2.0 */
+  CK_VERSION    hardwareVersion;  /* version of hardware */
+  CK_VERSION    firmwareVersion;  /* version of firmware */
+} CK_SLOT_INFO;
+
+/* flags: bit flags that provide capabilities of the slot
+ *      Bit Flag              Mask        Meaning
+ */
+#define CKF_TOKEN_PRESENT     0x00000001  /* a token is there */
+#define CKF_REMOVABLE_DEVICE  0x00000002  /* removable devices*/
+#define CKF_HW_SLOT           0x00000004  /* hardware slot */
+
+typedef CK_SLOT_INFO CK_PTR CK_SLOT_INFO_PTR;
+
+
+/* CK_TOKEN_INFO provides information about a token */
+typedef struct CK_TOKEN_INFO {
+  /* label, manufacturerID, and model have been changed from
+   * CK_CHAR to CK_UTF8CHAR for v2.10 */
+  CK_UTF8CHAR   label[32];           /* blank padded */
+  CK_UTF8CHAR   manufacturerID[32];  /* blank padded */
+  CK_UTF8CHAR   model[16];           /* blank padded */
+  CK_CHAR       serialNumber[16];    /* blank padded */
+  CK_FLAGS      flags;               /* see below */
+
+  /* ulMaxSessionCount, ulSessionCount, ulMaxRwSessionCount,
+   * ulRwSessionCount, ulMaxPinLen, and ulMinPinLen have all been
+   * changed from CK_USHORT to CK_ULONG for v2.0 */
+  CK_ULONG      ulMaxSessionCount;     /* max open sessions */
+  CK_ULONG      ulSessionCount;        /* sess. now open */
+  CK_ULONG      ulMaxRwSessionCount;   /* max R/W sessions */
+  CK_ULONG      ulRwSessionCount;      /* R/W sess. now open */
+  CK_ULONG      ulMaxPinLen;           /* in bytes */
+  CK_ULONG      ulMinPinLen;           /* in bytes */
+  CK_ULONG      ulTotalPublicMemory;   /* in bytes */
+  CK_ULONG      ulFreePublicMemory;    /* in bytes */
+  CK_ULONG      ulTotalPrivateMemory;  /* in bytes */
+  CK_ULONG      ulFreePrivateMemory;   /* in bytes */
+
+  /* hardwareVersion, firmwareVersion, and time are new for
+   * v2.0 */
+  CK_VERSION    hardwareVersion;       /* version of hardware */
+  CK_VERSION    firmwareVersion;       /* version of firmware */
+  CK_CHAR       utcTime[16];           /* time */
+} CK_TOKEN_INFO;
+
+/* The flags parameter is defined as follows:
+ *      Bit Flag                    Mask        Meaning
+ */
+#define CKF_RNG                     0x00000001  /* has random #
+                                                 * generator */
+#define CKF_WRITE_PROTECTED         0x00000002  /* token is
+                                                 * write-
+                                                 * protected */
+#define CKF_LOGIN_REQUIRED          0x00000004  /* user must
+                                                 * login */
+#define CKF_USER_PIN_INITIALIZED    0x00000008  /* normal user's
+                                                 * PIN is set */
+
+/* CKF_RESTORE_KEY_NOT_NEEDED is new for v2.0.  If it is set,
+ * that means that *every* time the state of cryptographic
+ * operations of a session is successfully saved, all keys
+ * needed to continue those operations are stored in the state */
+#define CKF_RESTORE_KEY_NOT_NEEDED  0x00000020
+
+/* CKF_CLOCK_ON_TOKEN is new for v2.0.  If it is set, that means
+ * that the token has some sort of clock.  The time on that
+ * clock is returned in the token info structure */
+#define CKF_CLOCK_ON_TOKEN          0x00000040
+
+/* CKF_PROTECTED_AUTHENTICATION_PATH is new for v2.0.  If it is
+ * set, that means that there is some way for the user to login
+ * without sending a PIN through the Cryptoki library itself */
+#define CKF_PROTECTED_AUTHENTICATION_PATH 0x00000100
+
+/* CKF_DUAL_CRYPTO_OPERATIONS is new for v2.0.  If it is true,
+ * that means that a single session with the token can perform
+ * dual simultaneous cryptographic operations (digest and
+ * encrypt; decrypt and digest; sign and encrypt; and decrypt
+ * and sign) */
+#define CKF_DUAL_CRYPTO_OPERATIONS  0x00000200
+
+/* CKF_TOKEN_INITIALIZED if new for v2.10. If it is true, the
+ * token has been initialized using C_InitializeToken or an
+ * equivalent mechanism outside the scope of PKCS #11.
+ * Calling C_InitializeToken when this flag is set will cause
+ * the token to be reinitialized. */
+#define CKF_TOKEN_INITIALIZED       0x00000400
+
+/* CKF_SECONDARY_AUTHENTICATION if new for v2.10. If it is
+ * true, the token supports secondary authentication for
+ * private key objects. This flag is deprecated in v2.11 and
+   onwards. */
+#define CKF_SECONDARY_AUTHENTICATION  0x00000800
+
+/* CKF_USER_PIN_COUNT_LOW if new for v2.10. If it is true, an
+ * incorrect user login PIN has been entered at least once
+ * since the last successful authentication. */
+#define CKF_USER_PIN_COUNT_LOW       0x00010000
+
+/* CKF_USER_PIN_FINAL_TRY if new for v2.10. If it is true,
+ * supplying an incorrect user PIN will it to become locked. */
+#define CKF_USER_PIN_FINAL_TRY       0x00020000
+
+/* CKF_USER_PIN_LOCKED if new for v2.10. If it is true, the
+ * user PIN has been locked. User login to the token is not
+ * possible. */
+#define CKF_USER_PIN_LOCKED          0x00040000
+
+/* CKF_USER_PIN_TO_BE_CHANGED if new for v2.10. If it is true,
+ * the user PIN value is the default value set by token
+ * initialization or manufacturing, or the PIN has been
+ * expired by the card. */
+#define CKF_USER_PIN_TO_BE_CHANGED   0x00080000
+
+/* CKF_SO_PIN_COUNT_LOW if new for v2.10. If it is true, an
+ * incorrect SO login PIN has been entered at least once since
+ * the last successful authentication. */
+#define CKF_SO_PIN_COUNT_LOW         0x00100000
+
+/* CKF_SO_PIN_FINAL_TRY if new for v2.10. If it is true,
+ * supplying an incorrect SO PIN will it to become locked. */
+#define CKF_SO_PIN_FINAL_TRY         0x00200000
+
+/* CKF_SO_PIN_LOCKED if new for v2.10. If it is true, the SO
+ * PIN has been locked. SO login to the token is not possible.
+ */
+#define CKF_SO_PIN_LOCKED            0x00400000
+
+/* CKF_SO_PIN_TO_BE_CHANGED if new for v2.10. If it is true,
+ * the SO PIN value is the default value set by token
+ * initialization or manufacturing, or the PIN has been
+ * expired by the card. */
+#define CKF_SO_PIN_TO_BE_CHANGED     0x00800000
+
+typedef CK_TOKEN_INFO CK_PTR CK_TOKEN_INFO_PTR;
+
+
+/* CK_SESSION_HANDLE is a Cryptoki-assigned value that
+ * identifies a session */
+typedef CK_ULONG          CK_SESSION_HANDLE;
+
+typedef CK_SESSION_HANDLE CK_PTR CK_SESSION_HANDLE_PTR;
+
+
+/* CK_USER_TYPE enumerates the types of Cryptoki users */
+/* CK_USER_TYPE has been changed from an enum to a CK_ULONG for
+ * v2.0 */
+typedef CK_ULONG          CK_USER_TYPE;
+/* Security Officer */
+#define CKU_SO    0
+/* Normal user */
+#define CKU_USER  1
+/* Context specific (added in v2.20) */
+#define CKU_CONTEXT_SPECIFIC   2
+
+/* CK_STATE enumerates the session states */
+/* CK_STATE has been changed from an enum to a CK_ULONG for
+ * v2.0 */
+typedef CK_ULONG          CK_STATE;
+#define CKS_RO_PUBLIC_SESSION  0
+#define CKS_RO_USER_FUNCTIONS  1
+#define CKS_RW_PUBLIC_SESSION  2
+#define CKS_RW_USER_FUNCTIONS  3
+#define CKS_RW_SO_FUNCTIONS    4
+
+
+/* CK_SESSION_INFO provides information about a session */
+typedef struct CK_SESSION_INFO {
+  CK_SLOT_ID    slotID;
+  CK_STATE      state;
+  CK_FLAGS      flags;          /* see below */
+
+  /* ulDeviceError was changed from CK_USHORT to CK_ULONG for
+   * v2.0 */
+  CK_ULONG      ulDeviceError;  /* device-dependent error code */
+} CK_SESSION_INFO;
+
+/* The flags are defined in the following table:
+ *      Bit Flag                Mask        Meaning
+ */
+#define CKF_RW_SESSION          0x00000002  /* session is r/w */
+#define CKF_SERIAL_SESSION      0x00000004  /* no parallel */
+
+typedef CK_SESSION_INFO CK_PTR CK_SESSION_INFO_PTR;
+
+
+/* CK_OBJECT_HANDLE is a token-specific identifier for an
+ * object  */
+typedef CK_ULONG          CK_OBJECT_HANDLE;
+
+typedef CK_OBJECT_HANDLE CK_PTR CK_OBJECT_HANDLE_PTR;
+
+
+/* CK_OBJECT_CLASS is a value that identifies the classes (or
+ * types) of objects that Cryptoki recognizes.  It is defined
+ * as follows: */
+/* CK_OBJECT_CLASS was changed from CK_USHORT to CK_ULONG for
+ * v2.0 */
+typedef CK_ULONG          CK_OBJECT_CLASS;
+
+/* The following classes of objects are defined: */
+/* CKO_HW_FEATURE is new for v2.10 */
+/* CKO_DOMAIN_PARAMETERS is new for v2.11 */
+/* CKO_MECHANISM is new for v2.20 */
+#define CKO_DATA              0x00000000
+#define CKO_CERTIFICATE       0x00000001
+#define CKO_PUBLIC_KEY        0x00000002
+#define CKO_PRIVATE_KEY       0x00000003
+#define CKO_SECRET_KEY        0x00000004
+#define CKO_HW_FEATURE        0x00000005
+#define CKO_DOMAIN_PARAMETERS 0x00000006
+#define CKO_MECHANISM         0x00000007
+#define CKO_VENDOR_DEFINED    0x80000000
+
+typedef CK_OBJECT_CLASS CK_PTR CK_OBJECT_CLASS_PTR;
+
+/* CK_HW_FEATURE_TYPE is new for v2.10. CK_HW_FEATURE_TYPE is a
+ * value that identifies the hardware feature type of an object
+ * with CK_OBJECT_CLASS equal to CKO_HW_FEATURE. */
+typedef CK_ULONG          CK_HW_FEATURE_TYPE;
+
+/* The following hardware feature types are defined */
+/* CKH_USER_INTERFACE is new for v2.20 */
+#define CKH_MONOTONIC_COUNTER  0x00000001
+#define CKH_CLOCK           0x00000002
+#define CKH_USER_INTERFACE  0x00000003
+#define CKH_VENDOR_DEFINED  0x80000000
+
+/* CK_KEY_TYPE is a value that identifies a key type */
+/* CK_KEY_TYPE was changed from CK_USHORT to CK_ULONG for v2.0 */
+typedef CK_ULONG          CK_KEY_TYPE;
+
+/* the following key types are defined: */
+#define CKK_RSA             0x00000000
+#define CKK_DSA             0x00000001
+#define CKK_DH              0x00000002
+
+/* CKK_ECDSA and CKK_KEA are new for v2.0 */
+/* CKK_ECDSA is deprecated in v2.11, CKK_EC is preferred. */
+#define CKK_ECDSA           0x00000003
+#define CKK_EC              0x00000003
+#define CKK_X9_42_DH        0x00000004
+#define CKK_KEA             0x00000005
+
+#define CKK_GENERIC_SECRET  0x00000010
+#define CKK_RC2             0x00000011
+#define CKK_RC4             0x00000012
+#define CKK_DES             0x00000013
+#define CKK_DES2            0x00000014
+#define CKK_DES3            0x00000015
+
+/* all these key types are new for v2.0 */
+#define CKK_CAST            0x00000016
+#define CKK_CAST3           0x00000017
+/* CKK_CAST5 is deprecated in v2.11, CKK_CAST128 is preferred. */
+#define CKK_CAST5           0x00000018
+#define CKK_CAST128         0x00000018
+#define CKK_RC5             0x00000019
+#define CKK_IDEA            0x0000001A
+#define CKK_SKIPJACK        0x0000001B
+#define CKK_BATON           0x0000001C
+#define CKK_JUNIPER         0x0000001D
+#define CKK_CDMF            0x0000001E
+#define CKK_AES             0x0000001F
+
+/* BlowFish and TwoFish are new for v2.20 */
+#define CKK_BLOWFISH        0x00000020
+#define CKK_TWOFISH         0x00000021
+
+#define CKK_VENDOR_DEFINED  0x80000000
+
+
+/* CK_CERTIFICATE_TYPE is a value that identifies a certificate
+ * type */
+/* CK_CERTIFICATE_TYPE was changed from CK_USHORT to CK_ULONG
+ * for v2.0 */
+typedef CK_ULONG          CK_CERTIFICATE_TYPE;
+
+/* The following certificate types are defined: */
+/* CKC_X_509_ATTR_CERT is new for v2.10 */
+/* CKC_WTLS is new for v2.20 */
+#define CKC_X_509           0x00000000
+#define CKC_X_509_ATTR_CERT 0x00000001
+#define CKC_WTLS            0x00000002
+#define CKC_VENDOR_DEFINED  0x80000000
+
+
+/* CK_ATTRIBUTE_TYPE is a value that identifies an attribute
+ * type */
+/* CK_ATTRIBUTE_TYPE was changed from CK_USHORT to CK_ULONG for
+ * v2.0 */
+typedef CK_ULONG          CK_ATTRIBUTE_TYPE;
+
+/* The CKF_ARRAY_ATTRIBUTE flag identifies an attribute which
+   consists of an array of values. */
+#define CKF_ARRAY_ATTRIBUTE    0x40000000
+
+/* The following attribute types are defined: */
+#define CKA_CLASS              0x00000000
+#define CKA_TOKEN              0x00000001
+#define CKA_PRIVATE            0x00000002
+#define CKA_LABEL              0x00000003
+#define CKA_APPLICATION        0x00000010
+#define CKA_VALUE              0x00000011
+
+/* CKA_OBJECT_ID is new for v2.10 */
+#define CKA_OBJECT_ID          0x00000012
+
+#define CKA_CERTIFICATE_TYPE   0x00000080
+#define CKA_ISSUER             0x00000081
+#define CKA_SERIAL_NUMBER      0x00000082
+
+/* CKA_AC_ISSUER, CKA_OWNER, and CKA_ATTR_TYPES are new
+ * for v2.10 */
+#define CKA_AC_ISSUER          0x00000083
+#define CKA_OWNER              0x00000084
+#define CKA_ATTR_TYPES         0x00000085
+
+/* CKA_TRUSTED is new for v2.11 */
+#define CKA_TRUSTED            0x00000086
+
+/* CKA_CERTIFICATE_CATEGORY ...
+ * CKA_CHECK_VALUE are new for v2.20 */
+#define CKA_CERTIFICATE_CATEGORY        0x00000087
+#define CKA_JAVA_MIDP_SECURITY_DOMAIN   0x00000088
+#define CKA_URL                         0x00000089
+#define CKA_HASH_OF_SUBJECT_PUBLIC_KEY  0x0000008A
+#define CKA_HASH_OF_ISSUER_PUBLIC_KEY   0x0000008B
+#define CKA_CHECK_VALUE                 0x00000090
+
+#define CKA_KEY_TYPE           0x00000100
+#define CKA_SUBJECT            0x00000101
+#define CKA_ID                 0x00000102
+#define CKA_SENSITIVE          0x00000103
+#define CKA_ENCRYPT            0x00000104
+#define CKA_DECRYPT            0x00000105
+#define CKA_WRAP               0x00000106
+#define CKA_UNWRAP             0x00000107
+#define CKA_SIGN               0x00000108
+#define CKA_SIGN_RECOVER       0x00000109
+#define CKA_VERIFY             0x0000010A
+#define CKA_VERIFY_RECOVER     0x0000010B
+#define CKA_DERIVE             0x0000010C
+#define CKA_START_DATE         0x00000110
+#define CKA_END_DATE           0x00000111
+#define CKA_MODULUS            0x00000120
+#define CKA_MODULUS_BITS       0x00000121
+#define CKA_PUBLIC_EXPONENT    0x00000122
+#define CKA_PRIVATE_EXPONENT   0x00000123
+#define CKA_PRIME_1            0x00000124
+#define CKA_PRIME_2            0x00000125
+#define CKA_EXPONENT_1         0x00000126
+#define CKA_EXPONENT_2         0x00000127
+#define CKA_COEFFICIENT        0x00000128
+#define CKA_PRIME              0x00000130
+#define CKA_SUBPRIME           0x00000131
+#define CKA_BASE               0x00000132
+
+/* CKA_PRIME_BITS and CKA_SUB_PRIME_BITS are new for v2.11 */
+#define CKA_PRIME_BITS         0x00000133
+#define CKA_SUBPRIME_BITS      0x00000134
+#define CKA_SUB_PRIME_BITS     CKA_SUBPRIME_BITS
+/* (To retain backwards-compatibility) */
+
+#define CKA_VALUE_BITS         0x00000160
+#define CKA_VALUE_LEN          0x00000161
+
+/* CKA_EXTRACTABLE, CKA_LOCAL, CKA_NEVER_EXTRACTABLE,
+ * CKA_ALWAYS_SENSITIVE, CKA_MODIFIABLE, CKA_ECDSA_PARAMS,
+ * and CKA_EC_POINT are new for v2.0 */
+#define CKA_EXTRACTABLE        0x00000162
+#define CKA_LOCAL              0x00000163
+#define CKA_NEVER_EXTRACTABLE  0x00000164
+#define CKA_ALWAYS_SENSITIVE   0x00000165
+
+/* CKA_KEY_GEN_MECHANISM is new for v2.11 */
+#define CKA_KEY_GEN_MECHANISM  0x00000166
+
+#define CKA_MODIFIABLE         0x00000170
+
+/* CKA_ECDSA_PARAMS is deprecated in v2.11,
+ * CKA_EC_PARAMS is preferred. */
+#define CKA_ECDSA_PARAMS       0x00000180
+#define CKA_EC_PARAMS          0x00000180
+
+#define CKA_EC_POINT           0x00000181
+
+/* CKA_SECONDARY_AUTH, CKA_AUTH_PIN_FLAGS,
+ * are new for v2.10. Deprecated in v2.11 and onwards. */
+#define CKA_SECONDARY_AUTH     0x00000200
+#define CKA_AUTH_PIN_FLAGS     0x00000201
+
+/* CKA_ALWAYS_AUTHENTICATE ...
+ * CKA_UNWRAP_TEMPLATE are new for v2.20 */
+#define CKA_ALWAYS_AUTHENTICATE  0x00000202
+
+#define CKA_WRAP_WITH_TRUSTED    0x00000210
+#define CKA_WRAP_TEMPLATE        (CKF_ARRAY_ATTRIBUTE|0x00000211)
+#define CKA_UNWRAP_TEMPLATE      (CKF_ARRAY_ATTRIBUTE|0x00000212)
+
+/* CKA_HW_FEATURE_TYPE, CKA_RESET_ON_INIT, and CKA_HAS_RESET
+ * are new for v2.10 */
+#define CKA_HW_FEATURE_TYPE    0x00000300
+#define CKA_RESET_ON_INIT      0x00000301
+#define CKA_HAS_RESET          0x00000302
+
+/* The following attributes are new for v2.20 */
+#define CKA_PIXEL_X                     0x00000400
+#define CKA_PIXEL_Y                     0x00000401
+#define CKA_RESOLUTION                  0x00000402
+#define CKA_CHAR_ROWS                   0x00000403
+#define CKA_CHAR_COLUMNS                0x00000404
+#define CKA_COLOR                       0x00000405
+#define CKA_BITS_PER_PIXEL              0x00000406
+#define CKA_CHAR_SETS                   0x00000480
+#define CKA_ENCODING_METHODS            0x00000481
+#define CKA_MIME_TYPES                  0x00000482
+#define CKA_MECHANISM_TYPE              0x00000500
+#define CKA_REQUIRED_CMS_ATTRIBUTES     0x00000501
+#define CKA_DEFAULT_CMS_ATTRIBUTES      0x00000502
+#define CKA_SUPPORTED_CMS_ATTRIBUTES    0x00000503
+#define CKA_ALLOWED_MECHANISMS          (CKF_ARRAY_ATTRIBUTE|0x00000600)
+
+#define CKA_VENDOR_DEFINED     0x80000000
+
+
+/* CK_ATTRIBUTE is a structure that includes the type, length
+ * and value of an attribute */
+typedef struct CK_ATTRIBUTE {
+  CK_ATTRIBUTE_TYPE type;
+  CK_VOID_PTR       pValue;
+
+  /* ulValueLen went from CK_USHORT to CK_ULONG for v2.0 */
+  CK_ULONG          ulValueLen;  /* in bytes */
+} CK_ATTRIBUTE;
+
+typedef CK_ATTRIBUTE CK_PTR CK_ATTRIBUTE_PTR;
+
+
+/* CK_DATE is a structure that defines a date */
+typedef struct CK_DATE{
+  CK_CHAR       year[4];   /* the year ("1900" - "9999") */
+  CK_CHAR       month[2];  /* the month ("01" - "12") */
+  CK_CHAR       day[2];    /* the day   ("01" - "31") */
+} CK_DATE;
+
+
+/* CK_MECHANISM_TYPE is a value that identifies a mechanism
+ * type */
+/* CK_MECHANISM_TYPE was changed from CK_USHORT to CK_ULONG for
+ * v2.0 */
+typedef CK_ULONG          CK_MECHANISM_TYPE;
+
+/* the following mechanism types are defined: */
+#define CKM_RSA_PKCS_KEY_PAIR_GEN      0x00000000
+#define CKM_RSA_PKCS                   0x00000001
+#define CKM_RSA_9796                   0x00000002
+#define CKM_RSA_X_509                  0x00000003
+
+/* CKM_MD2_RSA_PKCS, CKM_MD5_RSA_PKCS, and CKM_SHA1_RSA_PKCS
+ * are new for v2.0.  They are mechanisms which hash and sign */
+#define CKM_MD2_RSA_PKCS               0x00000004
+#define CKM_MD5_RSA_PKCS               0x00000005
+#define CKM_SHA1_RSA_PKCS              0x00000006
+
+/* CKM_RIPEMD128_RSA_PKCS, CKM_RIPEMD160_RSA_PKCS, and
+ * CKM_RSA_PKCS_OAEP are new for v2.10 */
+#define CKM_RIPEMD128_RSA_PKCS         0x00000007
+#define CKM_RIPEMD160_RSA_PKCS         0x00000008
+#define CKM_RSA_PKCS_OAEP              0x00000009
+
+/* CKM_RSA_X9_31_KEY_PAIR_GEN, CKM_RSA_X9_31, CKM_SHA1_RSA_X9_31,
+ * CKM_RSA_PKCS_PSS, and CKM_SHA1_RSA_PKCS_PSS are new for v2.11 */
+#define CKM_RSA_X9_31_KEY_PAIR_GEN     0x0000000A
+#define CKM_RSA_X9_31                  0x0000000B
+#define CKM_SHA1_RSA_X9_31             0x0000000C
+#define CKM_RSA_PKCS_PSS               0x0000000D
+#define CKM_SHA1_RSA_PKCS_PSS          0x0000000E
+
+#define CKM_DSA_KEY_PAIR_GEN           0x00000010
+#define CKM_DSA                        0x00000011
+#define CKM_DSA_SHA1                   0x00000012
+#define CKM_DH_PKCS_KEY_PAIR_GEN       0x00000020
+#define CKM_DH_PKCS_DERIVE             0x00000021
+
+/* CKM_X9_42_DH_KEY_PAIR_GEN, CKM_X9_42_DH_DERIVE,
+ * CKM_X9_42_DH_HYBRID_DERIVE, and CKM_X9_42_MQV_DERIVE are new for
+ * v2.11 */
+#define CKM_X9_42_DH_KEY_PAIR_GEN      0x00000030
+#define CKM_X9_42_DH_DERIVE            0x00000031
+#define CKM_X9_42_DH_HYBRID_DERIVE     0x00000032
+#define CKM_X9_42_MQV_DERIVE           0x00000033
+
+/* CKM_SHA256/384/512 are new for v2.20 */
+#define CKM_SHA256_RSA_PKCS            0x00000040
+#define CKM_SHA384_RSA_PKCS            0x00000041
+#define CKM_SHA512_RSA_PKCS            0x00000042
+#define CKM_SHA256_RSA_PKCS_PSS        0x00000043
+#define CKM_SHA384_RSA_PKCS_PSS        0x00000044
+#define CKM_SHA512_RSA_PKCS_PSS        0x00000045
+
+#define CKM_RC2_KEY_GEN                0x00000100
+#define CKM_RC2_ECB                    0x00000101
+#define CKM_RC2_CBC                    0x00000102
+#define CKM_RC2_MAC                    0x00000103
+
+/* CKM_RC2_MAC_GENERAL and CKM_RC2_CBC_PAD are new for v2.0 */
+#define CKM_RC2_MAC_GENERAL            0x00000104
+#define CKM_RC2_CBC_PAD                0x00000105
+
+#define CKM_RC4_KEY_GEN                0x00000110
+#define CKM_RC4                        0x00000111
+#define CKM_DES_KEY_GEN                0x00000120
+#define CKM_DES_ECB                    0x00000121
+#define CKM_DES_CBC                    0x00000122
+#define CKM_DES_MAC                    0x00000123
+
+/* CKM_DES_MAC_GENERAL and CKM_DES_CBC_PAD are new for v2.0 */
+#define CKM_DES_MAC_GENERAL            0x00000124
+#define CKM_DES_CBC_PAD                0x00000125
+
+#define CKM_DES2_KEY_GEN               0x00000130
+#define CKM_DES3_KEY_GEN               0x00000131
+#define CKM_DES3_ECB                   0x00000132
+#define CKM_DES3_CBC                   0x00000133
+#define CKM_DES3_MAC                   0x00000134
+
+/* CKM_DES3_MAC_GENERAL, CKM_DES3_CBC_PAD, CKM_CDMF_KEY_GEN,
+ * CKM_CDMF_ECB, CKM_CDMF_CBC, CKM_CDMF_MAC,
+ * CKM_CDMF_MAC_GENERAL, and CKM_CDMF_CBC_PAD are new for v2.0 */
+#define CKM_DES3_MAC_GENERAL           0x00000135
+#define CKM_DES3_CBC_PAD               0x00000136
+#define CKM_CDMF_KEY_GEN               0x00000140
+#define CKM_CDMF_ECB                   0x00000141
+#define CKM_CDMF_CBC                   0x00000142
+#define CKM_CDMF_MAC                   0x00000143
+#define CKM_CDMF_MAC_GENERAL           0x00000144
+#define CKM_CDMF_CBC_PAD               0x00000145
+
+/* the following four DES mechanisms are new for v2.20 */
+#define CKM_DES_OFB64                  0x00000150
+#define CKM_DES_OFB8                   0x00000151
+#define CKM_DES_CFB64                  0x00000152
+#define CKM_DES_CFB8                   0x00000153
+
+#define CKM_MD2                        0x00000200
+
+/* CKM_MD2_HMAC and CKM_MD2_HMAC_GENERAL are new for v2.0 */
+#define CKM_MD2_HMAC                   0x00000201
+#define CKM_MD2_HMAC_GENERAL           0x00000202
+
+#define CKM_MD5                        0x00000210
+
+/* CKM_MD5_HMAC and CKM_MD5_HMAC_GENERAL are new for v2.0 */
+#define CKM_MD5_HMAC                   0x00000211
+#define CKM_MD5_HMAC_GENERAL           0x00000212
+
+#define CKM_SHA_1                      0x00000220
+
+/* CKM_SHA_1_HMAC and CKM_SHA_1_HMAC_GENERAL are new for v2.0 */
+#define CKM_SHA_1_HMAC                 0x00000221
+#define CKM_SHA_1_HMAC_GENERAL         0x00000222
+
+/* CKM_RIPEMD128, CKM_RIPEMD128_HMAC,
+ * CKM_RIPEMD128_HMAC_GENERAL, CKM_RIPEMD160, CKM_RIPEMD160_HMAC,
+ * and CKM_RIPEMD160_HMAC_GENERAL are new for v2.10 */
+#define CKM_RIPEMD128                  0x00000230
+#define CKM_RIPEMD128_HMAC             0x00000231
+#define CKM_RIPEMD128_HMAC_GENERAL     0x00000232
+#define CKM_RIPEMD160                  0x00000240
+#define CKM_RIPEMD160_HMAC             0x00000241
+#define CKM_RIPEMD160_HMAC_GENERAL     0x00000242
+
+/* CKM_SHA256/384/512 are new for v2.20 */
+#define CKM_SHA256                     0x00000250
+#define CKM_SHA256_HMAC                0x00000251
+#define CKM_SHA256_HMAC_GENERAL        0x00000252
+#define CKM_SHA384                     0x00000260
+#define CKM_SHA384_HMAC                0x00000261
+#define CKM_SHA384_HMAC_GENERAL        0x00000262
+#define CKM_SHA512                     0x00000270
+#define CKM_SHA512_HMAC                0x00000271
+#define CKM_SHA512_HMAC_GENERAL        0x00000272
+
+/* All of the following mechanisms are new for v2.0 */
+/* Note that CAST128 and CAST5 are the same algorithm */
+#define CKM_CAST_KEY_GEN               0x00000300
+#define CKM_CAST_ECB                   0x00000301
+#define CKM_CAST_CBC                   0x00000302
+#define CKM_CAST_MAC                   0x00000303
+#define CKM_CAST_MAC_GENERAL           0x00000304
+#define CKM_CAST_CBC_PAD               0x00000305
+#define CKM_CAST3_KEY_GEN              0x00000310
+#define CKM_CAST3_ECB                  0x00000311
+#define CKM_CAST3_CBC                  0x00000312
+#define CKM_CAST3_MAC                  0x00000313
+#define CKM_CAST3_MAC_GENERAL          0x00000314
+#define CKM_CAST3_CBC_PAD              0x00000315
+#define CKM_CAST5_KEY_GEN              0x00000320
+#define CKM_CAST128_KEY_GEN            0x00000320
+#define CKM_CAST5_ECB                  0x00000321
+#define CKM_CAST128_ECB                0x00000321
+#define CKM_CAST5_CBC                  0x00000322
+#define CKM_CAST128_CBC                0x00000322
+#define CKM_CAST5_MAC                  0x00000323
+#define CKM_CAST128_MAC                0x00000323
+#define CKM_CAST5_MAC_GENERAL          0x00000324
+#define CKM_CAST128_MAC_GENERAL        0x00000324
+#define CKM_CAST5_CBC_PAD              0x00000325
+#define CKM_CAST128_CBC_PAD            0x00000325
+#define CKM_RC5_KEY_GEN                0x00000330
+#define CKM_RC5_ECB                    0x00000331
+#define CKM_RC5_CBC                    0x00000332
+#define CKM_RC5_MAC                    0x00000333
+#define CKM_RC5_MAC_GENERAL            0x00000334
+#define CKM_RC5_CBC_PAD                0x00000335
+#define CKM_IDEA_KEY_GEN               0x00000340
+#define CKM_IDEA_ECB                   0x00000341
+#define CKM_IDEA_CBC                   0x00000342
+#define CKM_IDEA_MAC                   0x00000343
+#define CKM_IDEA_MAC_GENERAL           0x00000344
+#define CKM_IDEA_CBC_PAD               0x00000345
+#define CKM_GENERIC_SECRET_KEY_GEN     0x00000350
+#define CKM_CONCATENATE_BASE_AND_KEY   0x00000360
+#define CKM_CONCATENATE_BASE_AND_DATA  0x00000362
+#define CKM_CONCATENATE_DATA_AND_BASE  0x00000363
+#define CKM_XOR_BASE_AND_DATA          0x00000364
+#define CKM_EXTRACT_KEY_FROM_KEY       0x00000365
+#define CKM_SSL3_PRE_MASTER_KEY_GEN    0x00000370
+#define CKM_SSL3_MASTER_KEY_DERIVE     0x00000371
+#define CKM_SSL3_KEY_AND_MAC_DERIVE    0x00000372
+
+/* CKM_SSL3_MASTER_KEY_DERIVE_DH, CKM_TLS_PRE_MASTER_KEY_GEN,
+ * CKM_TLS_MASTER_KEY_DERIVE, CKM_TLS_KEY_AND_MAC_DERIVE, and
+ * CKM_TLS_MASTER_KEY_DERIVE_DH are new for v2.11 */
+#define CKM_SSL3_MASTER_KEY_DERIVE_DH  0x00000373
+#define CKM_TLS_PRE_MASTER_KEY_GEN     0x00000374
+#define CKM_TLS_MASTER_KEY_DERIVE      0x00000375
+#define CKM_TLS_KEY_AND_MAC_DERIVE     0x00000376
+#define CKM_TLS_MASTER_KEY_DERIVE_DH   0x00000377
+
+/* CKM_TLS_PRF is new for v2.20 */
+#define CKM_TLS_PRF                    0x00000378
+
+#define CKM_SSL3_MD5_MAC               0x00000380
+#define CKM_SSL3_SHA1_MAC              0x00000381
+#define CKM_MD5_KEY_DERIVATION         0x00000390
+#define CKM_MD2_KEY_DERIVATION         0x00000391
+#define CKM_SHA1_KEY_DERIVATION        0x00000392
+
+/* CKM_SHA256/384/512 are new for v2.20 */
+#define CKM_SHA256_KEY_DERIVATION      0x00000393
+#define CKM_SHA384_KEY_DERIVATION      0x00000394
+#define CKM_SHA512_KEY_DERIVATION      0x00000395
+
+#define CKM_PBE_MD2_DES_CBC            0x000003A0
+#define CKM_PBE_MD5_DES_CBC            0x000003A1
+#define CKM_PBE_MD5_CAST_CBC           0x000003A2
+#define CKM_PBE_MD5_CAST3_CBC          0x000003A3
+#define CKM_PBE_MD5_CAST5_CBC          0x000003A4
+#define CKM_PBE_MD5_CAST128_CBC        0x000003A4
+#define CKM_PBE_SHA1_CAST5_CBC         0x000003A5
+#define CKM_PBE_SHA1_CAST128_CBC       0x000003A5
+#define CKM_PBE_SHA1_RC4_128           0x000003A6
+#define CKM_PBE_SHA1_RC4_40            0x000003A7
+#define CKM_PBE_SHA1_DES3_EDE_CBC      0x000003A8
+#define CKM_PBE_SHA1_DES2_EDE_CBC      0x000003A9
+#define CKM_PBE_SHA1_RC2_128_CBC       0x000003AA
+#define CKM_PBE_SHA1_RC2_40_CBC        0x000003AB
+
+/* CKM_PKCS5_PBKD2 is new for v2.10 */
+#define CKM_PKCS5_PBKD2                0x000003B0
+
+#define CKM_PBA_SHA1_WITH_SHA1_HMAC    0x000003C0
+
+/* WTLS mechanisms are new for v2.20 */
+#define CKM_WTLS_PRE_MASTER_KEY_GEN         0x000003D0
+#define CKM_WTLS_MASTER_KEY_DERIVE          0x000003D1
+#define CKM_WTLS_MASTER_KEY_DERIVE_DH_ECC   0x000003D2
+#define CKM_WTLS_PRF                        0x000003D3
+#define CKM_WTLS_SERVER_KEY_AND_MAC_DERIVE  0x000003D4
+#define CKM_WTLS_CLIENT_KEY_AND_MAC_DERIVE  0x000003D5
+
+#define CKM_KEY_WRAP_LYNKS             0x00000400
+#define CKM_KEY_WRAP_SET_OAEP          0x00000401
+
+/* CKM_CMS_SIG is new for v2.20 */
+#define CKM_CMS_SIG                    0x00000500
+
+/* Fortezza mechanisms */
+#define CKM_SKIPJACK_KEY_GEN           0x00001000
+#define CKM_SKIPJACK_ECB64             0x00001001
+#define CKM_SKIPJACK_CBC64             0x00001002
+#define CKM_SKIPJACK_OFB64             0x00001003
+#define CKM_SKIPJACK_CFB64             0x00001004
+#define CKM_SKIPJACK_CFB32             0x00001005
+#define CKM_SKIPJACK_CFB16             0x00001006
+#define CKM_SKIPJACK_CFB8              0x00001007
+#define CKM_SKIPJACK_WRAP              0x00001008
+#define CKM_SKIPJACK_PRIVATE_WRAP      0x00001009
+#define CKM_SKIPJACK_RELAYX            0x0000100a
+#define CKM_KEA_KEY_PAIR_GEN           0x00001010
+#define CKM_KEA_KEY_DERIVE             0x00001011
+#define CKM_FORTEZZA_TIMESTAMP         0x00001020
+#define CKM_BATON_KEY_GEN              0x00001030
+#define CKM_BATON_ECB128               0x00001031
+#define CKM_BATON_ECB96                0x00001032
+#define CKM_BATON_CBC128               0x00001033
+#define CKM_BATON_COUNTER              0x00001034
+#define CKM_BATON_SHUFFLE              0x00001035
+#define CKM_BATON_WRAP                 0x00001036
+
+/* CKM_ECDSA_KEY_PAIR_GEN is deprecated in v2.11,
+ * CKM_EC_KEY_PAIR_GEN is preferred */
+#define CKM_ECDSA_KEY_PAIR_GEN         0x00001040
+#define CKM_EC_KEY_PAIR_GEN            0x00001040
+
+#define CKM_ECDSA                      0x00001041
+#define CKM_ECDSA_SHA1                 0x00001042
+
+/* CKM_ECDH1_DERIVE, CKM_ECDH1_COFACTOR_DERIVE, and CKM_ECMQV_DERIVE
+ * are new for v2.11 */
+#define CKM_ECDH1_DERIVE               0x00001050
+#define CKM_ECDH1_COFACTOR_DERIVE      0x00001051
+#define CKM_ECMQV_DERIVE               0x00001052
+
+#define CKM_JUNIPER_KEY_GEN            0x00001060
+#define CKM_JUNIPER_ECB128             0x00001061
+#define CKM_JUNIPER_CBC128             0x00001062
+#define CKM_JUNIPER_COUNTER            0x00001063
+#define CKM_JUNIPER_SHUFFLE            0x00001064
+#define CKM_JUNIPER_WRAP               0x00001065
+#define CKM_FASTHASH                   0x00001070
+
+/* CKM_AES_KEY_GEN, CKM_AES_ECB, CKM_AES_CBC, CKM_AES_MAC,
+ * CKM_AES_MAC_GENERAL, CKM_AES_CBC_PAD, CKM_DSA_PARAMETER_GEN,
+ * CKM_DH_PKCS_PARAMETER_GEN, and CKM_X9_42_DH_PARAMETER_GEN are
+ * new for v2.11 */
+#define CKM_AES_KEY_GEN                0x00001080
+#define CKM_AES_ECB                    0x00001081
+#define CKM_AES_CBC                    0x00001082
+#define CKM_AES_MAC                    0x00001083
+#define CKM_AES_MAC_GENERAL            0x00001084
+#define CKM_AES_CBC_PAD                0x00001085
+
+/* BlowFish and TwoFish are new for v2.20 */
+#define CKM_BLOWFISH_KEY_GEN           0x00001090
+#define CKM_BLOWFISH_CBC               0x00001091
+#define CKM_TWOFISH_KEY_GEN            0x00001092
+#define CKM_TWOFISH_CBC                0x00001093
+
+
+/* CKM_xxx_ENCRYPT_DATA mechanisms are new for v2.20 */
+#define CKM_DES_ECB_ENCRYPT_DATA       0x00001100
+#define CKM_DES_CBC_ENCRYPT_DATA       0x00001101
+#define CKM_DES3_ECB_ENCRYPT_DATA      0x00001102
+#define CKM_DES3_CBC_ENCRYPT_DATA      0x00001103
+#define CKM_AES_ECB_ENCRYPT_DATA       0x00001104
+#define CKM_AES_CBC_ENCRYPT_DATA       0x00001105
+
+#define CKM_DSA_PARAMETER_GEN          0x00002000
+#define CKM_DH_PKCS_PARAMETER_GEN      0x00002001
+#define CKM_X9_42_DH_PARAMETER_GEN     0x00002002
+
+#define CKM_VENDOR_DEFINED             0x80000000
+
+typedef CK_MECHANISM_TYPE CK_PTR CK_MECHANISM_TYPE_PTR;
+
+
+/* CK_MECHANISM is a structure that specifies a particular
+ * mechanism  */
+typedef struct CK_MECHANISM {
+  CK_MECHANISM_TYPE mechanism;
+  CK_VOID_PTR       pParameter;
+
+  /* ulParameterLen was changed from CK_USHORT to CK_ULONG for
+   * v2.0 */
+  CK_ULONG          ulParameterLen;  /* in bytes */
+} CK_MECHANISM;
+
+typedef CK_MECHANISM CK_PTR CK_MECHANISM_PTR;
+
+
+/* CK_MECHANISM_INFO provides information about a particular
+ * mechanism */
+typedef struct CK_MECHANISM_INFO {
+    CK_ULONG    ulMinKeySize;
+    CK_ULONG    ulMaxKeySize;
+    CK_FLAGS    flags;
+} CK_MECHANISM_INFO;
+
+/* The flags are defined as follows:
+ *      Bit Flag               Mask        Meaning */
+#define CKF_HW                 0x00000001  /* performed by HW */
+
+/* The flags CKF_ENCRYPT, CKF_DECRYPT, CKF_DIGEST, CKF_SIGN,
+ * CKG_SIGN_RECOVER, CKF_VERIFY, CKF_VERIFY_RECOVER,
+ * CKF_GENERATE, CKF_GENERATE_KEY_PAIR, CKF_WRAP, CKF_UNWRAP,
+ * and CKF_DERIVE are new for v2.0.  They specify whether or not
+ * a mechanism can be used for a particular task */
+#define CKF_ENCRYPT            0x00000100
+#define CKF_DECRYPT            0x00000200
+#define CKF_DIGEST             0x00000400
+#define CKF_SIGN               0x00000800
+#define CKF_SIGN_RECOVER       0x00001000
+#define CKF_VERIFY             0x00002000
+#define CKF_VERIFY_RECOVER     0x00004000
+#define CKF_GENERATE           0x00008000
+#define CKF_GENERATE_KEY_PAIR  0x00010000
+#define CKF_WRAP               0x00020000
+#define CKF_UNWRAP             0x00040000
+#define CKF_DERIVE             0x00080000
+
+/* CKF_EC_F_P, CKF_EC_F_2M, CKF_EC_ECPARAMETERS, CKF_EC_NAMEDCURVE,
+ * CKF_EC_UNCOMPRESS, and CKF_EC_COMPRESS are new for v2.11. They
+ * describe a token's EC capabilities not available in mechanism
+ * information. */
+#define CKF_EC_F_P             0x00100000
+#define CKF_EC_F_2M            0x00200000
+#define CKF_EC_ECPARAMETERS    0x00400000
+#define CKF_EC_NAMEDCURVE      0x00800000
+#define CKF_EC_UNCOMPRESS      0x01000000
+#define CKF_EC_COMPRESS        0x02000000
+
+#define CKF_EXTENSION          0x80000000 /* FALSE for this version */
+
+typedef CK_MECHANISM_INFO CK_PTR CK_MECHANISM_INFO_PTR;
+
+
+/* CK_RV is a value that identifies the return value of a
+ * Cryptoki function */
+/* CK_RV was changed from CK_USHORT to CK_ULONG for v2.0 */
+typedef CK_ULONG          CK_RV;
+
+#define CKR_OK                                0x00000000
+#define CKR_CANCEL                            0x00000001
+#define CKR_HOST_MEMORY                       0x00000002
+#define CKR_SLOT_ID_INVALID                   0x00000003
+
+/* CKR_FLAGS_INVALID was removed for v2.0 */
+
+/* CKR_GENERAL_ERROR and CKR_FUNCTION_FAILED are new for v2.0 */
+#define CKR_GENERAL_ERROR                     0x00000005
+#define CKR_FUNCTION_FAILED                   0x00000006
+
+/* CKR_ARGUMENTS_BAD, CKR_NO_EVENT, CKR_NEED_TO_CREATE_THREADS,
+ * and CKR_CANT_LOCK are new for v2.01 */
+#define CKR_ARGUMENTS_BAD                     0x00000007
+#define CKR_NO_EVENT                          0x00000008
+#define CKR_NEED_TO_CREATE_THREADS            0x00000009
+#define CKR_CANT_LOCK                         0x0000000A
+
+#define CKR_ATTRIBUTE_READ_ONLY               0x00000010
+#define CKR_ATTRIBUTE_SENSITIVE               0x00000011
+#define CKR_ATTRIBUTE_TYPE_INVALID            0x00000012
+#define CKR_ATTRIBUTE_VALUE_INVALID           0x00000013
+#define CKR_DATA_INVALID                      0x00000020
+#define CKR_DATA_LEN_RANGE                    0x00000021
+#define CKR_DEVICE_ERROR                      0x00000030
+#define CKR_DEVICE_MEMORY                     0x00000031
+#define CKR_DEVICE_REMOVED                    0x00000032
+#define CKR_ENCRYPTED_DATA_INVALID            0x00000040
+#define CKR_ENCRYPTED_DATA_LEN_RANGE          0x00000041
+#define CKR_FUNCTION_CANCELED                 0x00000050
+#define CKR_FUNCTION_NOT_PARALLEL             0x00000051
+
+/* CKR_FUNCTION_NOT_SUPPORTED is new for v2.0 */
+#define CKR_FUNCTION_NOT_SUPPORTED            0x00000054
+
+#define CKR_KEY_HANDLE_INVALID                0x00000060
+
+/* CKR_KEY_SENSITIVE was removed for v2.0 */
+
+#define CKR_KEY_SIZE_RANGE                    0x00000062
+#define CKR_KEY_TYPE_INCONSISTENT             0x00000063
+
+/* CKR_KEY_NOT_NEEDED, CKR_KEY_CHANGED, CKR_KEY_NEEDED,
+ * CKR_KEY_INDIGESTIBLE, CKR_KEY_FUNCTION_NOT_PERMITTED,
+ * CKR_KEY_NOT_WRAPPABLE, and CKR_KEY_UNEXTRACTABLE are new for
+ * v2.0 */
+#define CKR_KEY_NOT_NEEDED                    0x00000064
+#define CKR_KEY_CHANGED                       0x00000065
+#define CKR_KEY_NEEDED                        0x00000066
+#define CKR_KEY_INDIGESTIBLE                  0x00000067
+#define CKR_KEY_FUNCTION_NOT_PERMITTED        0x00000068
+#define CKR_KEY_NOT_WRAPPABLE                 0x00000069
+#define CKR_KEY_UNEXTRACTABLE                 0x0000006A
+
+#define CKR_MECHANISM_INVALID                 0x00000070
+#define CKR_MECHANISM_PARAM_INVALID           0x00000071
+
+/* CKR_OBJECT_CLASS_INCONSISTENT and CKR_OBJECT_CLASS_INVALID
+ * were removed for v2.0 */
+#define CKR_OBJECT_HANDLE_INVALID             0x00000082
+#define CKR_OPERATION_ACTIVE                  0x00000090
+#define CKR_OPERATION_NOT_INITIALIZED         0x00000091
+#define CKR_PIN_INCORRECT                     0x000000A0
+#define CKR_PIN_INVALID                       0x000000A1
+#define CKR_PIN_LEN_RANGE                     0x000000A2
+
+/* CKR_PIN_EXPIRED and CKR_PIN_LOCKED are new for v2.0 */
+#define CKR_PIN_EXPIRED                       0x000000A3
+#define CKR_PIN_LOCKED                        0x000000A4
+
+#define CKR_SESSION_CLOSED                    0x000000B0
+#define CKR_SESSION_COUNT                     0x000000B1
+#define CKR_SESSION_HANDLE_INVALID            0x000000B3
+#define CKR_SESSION_PARALLEL_NOT_SUPPORTED    0x000000B4
+#define CKR_SESSION_READ_ONLY                 0x000000B5
+#define CKR_SESSION_EXISTS                    0x000000B6
+
+/* CKR_SESSION_READ_ONLY_EXISTS and
+ * CKR_SESSION_READ_WRITE_SO_EXISTS are new for v2.0 */
+#define CKR_SESSION_READ_ONLY_EXISTS          0x000000B7
+#define CKR_SESSION_READ_WRITE_SO_EXISTS      0x000000B8
+
+#define CKR_SIGNATURE_INVALID                 0x000000C0
+#define CKR_SIGNATURE_LEN_RANGE               0x000000C1
+#define CKR_TEMPLATE_INCOMPLETE               0x000000D0
+#define CKR_TEMPLATE_INCONSISTENT             0x000000D1
+#define CKR_TOKEN_NOT_PRESENT                 0x000000E0
+#define CKR_TOKEN_NOT_RECOGNIZED              0x000000E1
+#define CKR_TOKEN_WRITE_PROTECTED             0x000000E2
+#define CKR_UNWRAPPING_KEY_HANDLE_INVALID     0x000000F0
+#define CKR_UNWRAPPING_KEY_SIZE_RANGE         0x000000F1
+#define CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT  0x000000F2
+#define CKR_USER_ALREADY_LOGGED_IN            0x00000100
+#define CKR_USER_NOT_LOGGED_IN                0x00000101
+#define CKR_USER_PIN_NOT_INITIALIZED          0x00000102
+#define CKR_USER_TYPE_INVALID                 0x00000103
+
+/* CKR_USER_ANOTHER_ALREADY_LOGGED_IN and CKR_USER_TOO_MANY_TYPES
+ * are new to v2.01 */
+#define CKR_USER_ANOTHER_ALREADY_LOGGED_IN    0x00000104
+#define CKR_USER_TOO_MANY_TYPES               0x00000105
+
+#define CKR_WRAPPED_KEY_INVALID               0x00000110
+#define CKR_WRAPPED_KEY_LEN_RANGE             0x00000112
+#define CKR_WRAPPING_KEY_HANDLE_INVALID       0x00000113
+#define CKR_WRAPPING_KEY_SIZE_RANGE           0x00000114
+#define CKR_WRAPPING_KEY_TYPE_INCONSISTENT    0x00000115
+#define CKR_RANDOM_SEED_NOT_SUPPORTED         0x00000120
+
+/* These are new to v2.0 */
+#define CKR_RANDOM_NO_RNG                     0x00000121
+
+/* These are new to v2.11 */
+#define CKR_DOMAIN_PARAMS_INVALID             0x00000130
+
+/* These are new to v2.0 */
+#define CKR_BUFFER_TOO_SMALL                  0x00000150
+#define CKR_SAVED_STATE_INVALID               0x00000160
+#define CKR_INFORMATION_SENSITIVE             0x00000170
+#define CKR_STATE_UNSAVEABLE                  0x00000180
+
+/* These are new to v2.01 */
+#define CKR_CRYPTOKI_NOT_INITIALIZED          0x00000190
+#define CKR_CRYPTOKI_ALREADY_INITIALIZED      0x00000191
+#define CKR_MUTEX_BAD                         0x000001A0
+#define CKR_MUTEX_NOT_LOCKED                  0x000001A1
+
+/* This is new to v2.20 */
+#define CKR_FUNCTION_REJECTED                 0x00000200
+
+#define CKR_VENDOR_DEFINED                    0x80000000
+
+
+/* CK_NOTIFY is an application callback that processes events */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_NOTIFY)(
+  CK_SESSION_HANDLE hSession,     /* the session's handle */
+  CK_NOTIFICATION   event,
+  CK_VOID_PTR       pApplication  /* passed to C_OpenSession */
+);
+
+
+/* CK_FUNCTION_LIST is a structure holding a Cryptoki spec
+ * version and pointers of appropriate types to all the
+ * Cryptoki functions */
+/* CK_FUNCTION_LIST is new for v2.0 */
+typedef struct CK_FUNCTION_LIST CK_FUNCTION_LIST;
+
+typedef CK_FUNCTION_LIST CK_PTR CK_FUNCTION_LIST_PTR;
+
+typedef CK_FUNCTION_LIST_PTR CK_PTR CK_FUNCTION_LIST_PTR_PTR;
+
+
+/* CK_CREATEMUTEX is an application callback for creating a
+ * mutex object */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_CREATEMUTEX)(
+  CK_VOID_PTR_PTR ppMutex  /* location to receive ptr to mutex */
+);
+
+
+/* CK_DESTROYMUTEX is an application callback for destroying a
+ * mutex object */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_DESTROYMUTEX)(
+  CK_VOID_PTR pMutex  /* pointer to mutex */
+);
+
+
+/* CK_LOCKMUTEX is an application callback for locking a mutex */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_LOCKMUTEX)(
+  CK_VOID_PTR pMutex  /* pointer to mutex */
+);
+
+
+/* CK_UNLOCKMUTEX is an application callback for unlocking a
+ * mutex */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_UNLOCKMUTEX)(
+  CK_VOID_PTR pMutex  /* pointer to mutex */
+);
+
+
+/* CK_C_INITIALIZE_ARGS provides the optional arguments to
+ * C_Initialize */
+typedef struct CK_C_INITIALIZE_ARGS {
+  CK_CREATEMUTEX CreateMutex;
+  CK_DESTROYMUTEX DestroyMutex;
+  CK_LOCKMUTEX LockMutex;
+  CK_UNLOCKMUTEX UnlockMutex;
+  CK_FLAGS flags;
+  CK_VOID_PTR pReserved;
+} CK_C_INITIALIZE_ARGS;
+
+/* flags: bit flags that provide capabilities of the slot
+ *      Bit Flag                           Mask       Meaning
+ */
+#define CKF_LIBRARY_CANT_CREATE_OS_THREADS 0x00000001
+#define CKF_OS_LOCKING_OK                  0x00000002
+
+typedef CK_C_INITIALIZE_ARGS CK_PTR CK_C_INITIALIZE_ARGS_PTR;
+
+
+/* additional flags for parameters to functions */
+
+/* CKF_DONT_BLOCK is for the function C_WaitForSlotEvent */
+#define CKF_DONT_BLOCK     1
+
+/* CK_RSA_PKCS_OAEP_MGF_TYPE is new for v2.10.
+ * CK_RSA_PKCS_OAEP_MGF_TYPE  is used to indicate the Message
+ * Generation Function (MGF) applied to a message block when
+ * formatting a message block for the PKCS #1 OAEP encryption
+ * scheme. */
+typedef CK_ULONG CK_RSA_PKCS_MGF_TYPE;
+
+typedef CK_RSA_PKCS_MGF_TYPE CK_PTR CK_RSA_PKCS_MGF_TYPE_PTR;
+
+/* The following MGFs are defined */
+/* CKG_MGF1_SHA256, CKG_MGF1_SHA384, and CKG_MGF1_SHA512
+ * are new for v2.20 */
+#define CKG_MGF1_SHA1         0x00000001
+#define CKG_MGF1_SHA256       0x00000002
+#define CKG_MGF1_SHA384       0x00000003
+#define CKG_MGF1_SHA512       0x00000004
+
+/* CK_RSA_PKCS_OAEP_SOURCE_TYPE is new for v2.10.
+ * CK_RSA_PKCS_OAEP_SOURCE_TYPE  is used to indicate the source
+ * of the encoding parameter when formatting a message block
+ * for the PKCS #1 OAEP encryption scheme. */
+typedef CK_ULONG CK_RSA_PKCS_OAEP_SOURCE_TYPE;
+
+typedef CK_RSA_PKCS_OAEP_SOURCE_TYPE CK_PTR CK_RSA_PKCS_OAEP_SOURCE_TYPE_PTR;
+
+/* The following encoding parameter sources are defined */
+#define CKZ_DATA_SPECIFIED    0x00000001
+
+/* CK_RSA_PKCS_OAEP_PARAMS is new for v2.10.
+ * CK_RSA_PKCS_OAEP_PARAMS provides the parameters to the
+ * CKM_RSA_PKCS_OAEP mechanism. */
+typedef struct CK_RSA_PKCS_OAEP_PARAMS {
+        CK_MECHANISM_TYPE hashAlg;
+        CK_RSA_PKCS_MGF_TYPE mgf;
+        CK_RSA_PKCS_OAEP_SOURCE_TYPE source;
+        CK_VOID_PTR pSourceData;
+        CK_ULONG ulSourceDataLen;
+} CK_RSA_PKCS_OAEP_PARAMS;
+
+typedef CK_RSA_PKCS_OAEP_PARAMS CK_PTR CK_RSA_PKCS_OAEP_PARAMS_PTR;
+
+/* CK_RSA_PKCS_PSS_PARAMS is new for v2.11.
+ * CK_RSA_PKCS_PSS_PARAMS provides the parameters to the
+ * CKM_RSA_PKCS_PSS mechanism(s). */
+typedef struct CK_RSA_PKCS_PSS_PARAMS {
+        CK_MECHANISM_TYPE    hashAlg;
+        CK_RSA_PKCS_MGF_TYPE mgf;
+        CK_ULONG             sLen;
+} CK_RSA_PKCS_PSS_PARAMS;
+
+typedef CK_RSA_PKCS_PSS_PARAMS CK_PTR CK_RSA_PKCS_PSS_PARAMS_PTR;
+
+/* CK_EC_KDF_TYPE is new for v2.11. */
+typedef CK_ULONG CK_EC_KDF_TYPE;
+
+/* The following EC Key Derivation Functions are defined */
+#define CKD_NULL                 0x00000001
+#define CKD_SHA1_KDF             0x00000002
+
+/* CK_ECDH1_DERIVE_PARAMS is new for v2.11.
+ * CK_ECDH1_DERIVE_PARAMS provides the parameters to the
+ * CKM_ECDH1_DERIVE and CKM_ECDH1_COFACTOR_DERIVE mechanisms,
+ * where each party contributes one key pair.
+ */
+typedef struct CK_ECDH1_DERIVE_PARAMS {
+  CK_EC_KDF_TYPE kdf;
+  CK_ULONG ulSharedDataLen;
+  CK_BYTE_PTR pSharedData;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+} CK_ECDH1_DERIVE_PARAMS;
+
+typedef CK_ECDH1_DERIVE_PARAMS CK_PTR CK_ECDH1_DERIVE_PARAMS_PTR;
+
+
+/* CK_ECDH2_DERIVE_PARAMS is new for v2.11.
+ * CK_ECDH2_DERIVE_PARAMS provides the parameters to the
+ * CKM_ECMQV_DERIVE mechanism, where each party contributes two key pairs. */
+typedef struct CK_ECDH2_DERIVE_PARAMS {
+  CK_EC_KDF_TYPE kdf;
+  CK_ULONG ulSharedDataLen;
+  CK_BYTE_PTR pSharedData;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+  CK_ULONG ulPrivateDataLen;
+  CK_OBJECT_HANDLE hPrivateData;
+  CK_ULONG ulPublicDataLen2;
+  CK_BYTE_PTR pPublicData2;
+} CK_ECDH2_DERIVE_PARAMS;
+
+typedef CK_ECDH2_DERIVE_PARAMS CK_PTR CK_ECDH2_DERIVE_PARAMS_PTR;
+
+typedef struct CK_ECMQV_DERIVE_PARAMS {
+  CK_EC_KDF_TYPE kdf;
+  CK_ULONG ulSharedDataLen;
+  CK_BYTE_PTR pSharedData;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+  CK_ULONG ulPrivateDataLen;
+  CK_OBJECT_HANDLE hPrivateData;
+  CK_ULONG ulPublicDataLen2;
+  CK_BYTE_PTR pPublicData2;
+  CK_OBJECT_HANDLE publicKey;
+} CK_ECMQV_DERIVE_PARAMS;
+
+typedef CK_ECMQV_DERIVE_PARAMS CK_PTR CK_ECMQV_DERIVE_PARAMS_PTR;
+
+/* Typedefs and defines for the CKM_X9_42_DH_KEY_PAIR_GEN and the
+ * CKM_X9_42_DH_PARAMETER_GEN mechanisms (new for PKCS #11 v2.11) */
+typedef CK_ULONG CK_X9_42_DH_KDF_TYPE;
+typedef CK_X9_42_DH_KDF_TYPE CK_PTR CK_X9_42_DH_KDF_TYPE_PTR;
+
+/* The following X9.42 DH key derivation functions are defined
+   (besides CKD_NULL already defined : */
+#define CKD_SHA1_KDF_ASN1        0x00000003
+#define CKD_SHA1_KDF_CONCATENATE 0x00000004
+
+/* CK_X9_42_DH1_DERIVE_PARAMS is new for v2.11.
+ * CK_X9_42_DH1_DERIVE_PARAMS provides the parameters to the
+ * CKM_X9_42_DH_DERIVE key derivation mechanism, where each party
+ * contributes one key pair */
+typedef struct CK_X9_42_DH1_DERIVE_PARAMS {
+  CK_X9_42_DH_KDF_TYPE kdf;
+  CK_ULONG ulOtherInfoLen;
+  CK_BYTE_PTR pOtherInfo;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+} CK_X9_42_DH1_DERIVE_PARAMS;
+
+typedef struct CK_X9_42_DH1_DERIVE_PARAMS CK_PTR CK_X9_42_DH1_DERIVE_PARAMS_PTR;
+
+/* CK_X9_42_DH2_DERIVE_PARAMS is new for v2.11.
+ * CK_X9_42_DH2_DERIVE_PARAMS provides the parameters to the
+ * CKM_X9_42_DH_HYBRID_DERIVE and CKM_X9_42_MQV_DERIVE key derivation
+ * mechanisms, where each party contributes two key pairs */
+typedef struct CK_X9_42_DH2_DERIVE_PARAMS {
+  CK_X9_42_DH_KDF_TYPE kdf;
+  CK_ULONG ulOtherInfoLen;
+  CK_BYTE_PTR pOtherInfo;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+  CK_ULONG ulPrivateDataLen;
+  CK_OBJECT_HANDLE hPrivateData;
+  CK_ULONG ulPublicDataLen2;
+  CK_BYTE_PTR pPublicData2;
+} CK_X9_42_DH2_DERIVE_PARAMS;
+
+typedef CK_X9_42_DH2_DERIVE_PARAMS CK_PTR CK_X9_42_DH2_DERIVE_PARAMS_PTR;
+
+typedef struct CK_X9_42_MQV_DERIVE_PARAMS {
+  CK_X9_42_DH_KDF_TYPE kdf;
+  CK_ULONG ulOtherInfoLen;
+  CK_BYTE_PTR pOtherInfo;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+  CK_ULONG ulPrivateDataLen;
+  CK_OBJECT_HANDLE hPrivateData;
+  CK_ULONG ulPublicDataLen2;
+  CK_BYTE_PTR pPublicData2;
+  CK_OBJECT_HANDLE publicKey;
+} CK_X9_42_MQV_DERIVE_PARAMS;
+
+typedef CK_X9_42_MQV_DERIVE_PARAMS CK_PTR CK_X9_42_MQV_DERIVE_PARAMS_PTR;
+
+/* CK_KEA_DERIVE_PARAMS provides the parameters to the
+ * CKM_KEA_DERIVE mechanism */
+/* CK_KEA_DERIVE_PARAMS is new for v2.0 */
+typedef struct CK_KEA_DERIVE_PARAMS {
+  CK_BBOOL      isSender;
+  CK_ULONG      ulRandomLen;
+  CK_BYTE_PTR   pRandomA;
+  CK_BYTE_PTR   pRandomB;
+  CK_ULONG      ulPublicDataLen;
+  CK_BYTE_PTR   pPublicData;
+} CK_KEA_DERIVE_PARAMS;
+
+typedef CK_KEA_DERIVE_PARAMS CK_PTR CK_KEA_DERIVE_PARAMS_PTR;
+
+
+/* CK_RC2_PARAMS provides the parameters to the CKM_RC2_ECB and
+ * CKM_RC2_MAC mechanisms.  An instance of CK_RC2_PARAMS just
+ * holds the effective keysize */
+typedef CK_ULONG          CK_RC2_PARAMS;
+
+typedef CK_RC2_PARAMS CK_PTR CK_RC2_PARAMS_PTR;
+
+
+/* CK_RC2_CBC_PARAMS provides the parameters to the CKM_RC2_CBC
+ * mechanism */
+typedef struct CK_RC2_CBC_PARAMS {
+  /* ulEffectiveBits was changed from CK_USHORT to CK_ULONG for
+   * v2.0 */
+  CK_ULONG      ulEffectiveBits;  /* effective bits (1-1024) */
+
+  CK_BYTE       iv[8];            /* IV for CBC mode */
+} CK_RC2_CBC_PARAMS;
+
+typedef CK_RC2_CBC_PARAMS CK_PTR CK_RC2_CBC_PARAMS_PTR;
+
+
+/* CK_RC2_MAC_GENERAL_PARAMS provides the parameters for the
+ * CKM_RC2_MAC_GENERAL mechanism */
+/* CK_RC2_MAC_GENERAL_PARAMS is new for v2.0 */
+typedef struct CK_RC2_MAC_GENERAL_PARAMS {
+  CK_ULONG      ulEffectiveBits;  /* effective bits (1-1024) */
+  CK_ULONG      ulMacLength;      /* Length of MAC in bytes */
+} CK_RC2_MAC_GENERAL_PARAMS;
+
+typedef CK_RC2_MAC_GENERAL_PARAMS CK_PTR \
+  CK_RC2_MAC_GENERAL_PARAMS_PTR;
+
+
+/* CK_RC5_PARAMS provides the parameters to the CKM_RC5_ECB and
+ * CKM_RC5_MAC mechanisms */
+/* CK_RC5_PARAMS is new for v2.0 */
+typedef struct CK_RC5_PARAMS {
+  CK_ULONG      ulWordsize;  /* wordsize in bits */
+  CK_ULONG      ulRounds;    /* number of rounds */
+} CK_RC5_PARAMS;
+
+typedef CK_RC5_PARAMS CK_PTR CK_RC5_PARAMS_PTR;
+
+
+/* CK_RC5_CBC_PARAMS provides the parameters to the CKM_RC5_CBC
+ * mechanism */
+/* CK_RC5_CBC_PARAMS is new for v2.0 */
+typedef struct CK_RC5_CBC_PARAMS {
+  CK_ULONG      ulWordsize;  /* wordsize in bits */
+  CK_ULONG      ulRounds;    /* number of rounds */
+  CK_BYTE_PTR   pIv;         /* pointer to IV */
+  CK_ULONG      ulIvLen;     /* length of IV in bytes */
+} CK_RC5_CBC_PARAMS;
+
+typedef CK_RC5_CBC_PARAMS CK_PTR CK_RC5_CBC_PARAMS_PTR;
+
+
+/* CK_RC5_MAC_GENERAL_PARAMS provides the parameters for the
+ * CKM_RC5_MAC_GENERAL mechanism */
+/* CK_RC5_MAC_GENERAL_PARAMS is new for v2.0 */
+typedef struct CK_RC5_MAC_GENERAL_PARAMS {
+  CK_ULONG      ulWordsize;   /* wordsize in bits */
+  CK_ULONG      ulRounds;     /* number of rounds */
+  CK_ULONG      ulMacLength;  /* Length of MAC in bytes */
+} CK_RC5_MAC_GENERAL_PARAMS;
+
+typedef CK_RC5_MAC_GENERAL_PARAMS CK_PTR \
+  CK_RC5_MAC_GENERAL_PARAMS_PTR;
+
+
+/* CK_MAC_GENERAL_PARAMS provides the parameters to most block
+ * ciphers' MAC_GENERAL mechanisms.  Its value is the length of
+ * the MAC */
+/* CK_MAC_GENERAL_PARAMS is new for v2.0 */
+typedef CK_ULONG          CK_MAC_GENERAL_PARAMS;
+
+typedef CK_MAC_GENERAL_PARAMS CK_PTR CK_MAC_GENERAL_PARAMS_PTR;
+
+/* CK_DES/AES_ECB/CBC_ENCRYPT_DATA_PARAMS are new for v2.20 */
+typedef struct CK_DES_CBC_ENCRYPT_DATA_PARAMS {
+  CK_BYTE      iv[8];
+  CK_BYTE_PTR  pData;
+  CK_ULONG     length;
+} CK_DES_CBC_ENCRYPT_DATA_PARAMS;
+
+typedef CK_DES_CBC_ENCRYPT_DATA_PARAMS CK_PTR CK_DES_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+typedef struct CK_AES_CBC_ENCRYPT_DATA_PARAMS {
+  CK_BYTE      iv[16];
+  CK_BYTE_PTR  pData;
+  CK_ULONG     length;
+} CK_AES_CBC_ENCRYPT_DATA_PARAMS;
+
+typedef CK_AES_CBC_ENCRYPT_DATA_PARAMS CK_PTR CK_AES_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+/* CK_SKIPJACK_PRIVATE_WRAP_PARAMS provides the parameters to the
+ * CKM_SKIPJACK_PRIVATE_WRAP mechanism */
+/* CK_SKIPJACK_PRIVATE_WRAP_PARAMS is new for v2.0 */
+typedef struct CK_SKIPJACK_PRIVATE_WRAP_PARAMS {
+  CK_ULONG      ulPasswordLen;
+  CK_BYTE_PTR   pPassword;
+  CK_ULONG      ulPublicDataLen;
+  CK_BYTE_PTR   pPublicData;
+  CK_ULONG      ulPAndGLen;
+  CK_ULONG      ulQLen;
+  CK_ULONG      ulRandomLen;
+  CK_BYTE_PTR   pRandomA;
+  CK_BYTE_PTR   pPrimeP;
+  CK_BYTE_PTR   pBaseG;
+  CK_BYTE_PTR   pSubprimeQ;
+} CK_SKIPJACK_PRIVATE_WRAP_PARAMS;
+
+typedef CK_SKIPJACK_PRIVATE_WRAP_PARAMS CK_PTR \
+  CK_SKIPJACK_PRIVATE_WRAP_PTR;
+
+
+/* CK_SKIPJACK_RELAYX_PARAMS provides the parameters to the
+ * CKM_SKIPJACK_RELAYX mechanism */
+/* CK_SKIPJACK_RELAYX_PARAMS is new for v2.0 */
+typedef struct CK_SKIPJACK_RELAYX_PARAMS {
+  CK_ULONG      ulOldWrappedXLen;
+  CK_BYTE_PTR   pOldWrappedX;
+  CK_ULONG      ulOldPasswordLen;
+  CK_BYTE_PTR   pOldPassword;
+  CK_ULONG      ulOldPublicDataLen;
+  CK_BYTE_PTR   pOldPublicData;
+  CK_ULONG      ulOldRandomLen;
+  CK_BYTE_PTR   pOldRandomA;
+  CK_ULONG      ulNewPasswordLen;
+  CK_BYTE_PTR   pNewPassword;
+  CK_ULONG      ulNewPublicDataLen;
+  CK_BYTE_PTR   pNewPublicData;
+  CK_ULONG      ulNewRandomLen;
+  CK_BYTE_PTR   pNewRandomA;
+} CK_SKIPJACK_RELAYX_PARAMS;
+
+typedef CK_SKIPJACK_RELAYX_PARAMS CK_PTR \
+  CK_SKIPJACK_RELAYX_PARAMS_PTR;
+
+
+typedef struct CK_PBE_PARAMS {
+  CK_BYTE_PTR      pInitVector;
+  CK_UTF8CHAR_PTR  pPassword;
+  CK_ULONG         ulPasswordLen;
+  CK_BYTE_PTR      pSalt;
+  CK_ULONG         ulSaltLen;
+  CK_ULONG         ulIteration;
+} CK_PBE_PARAMS;
+
+typedef CK_PBE_PARAMS CK_PTR CK_PBE_PARAMS_PTR;
+
+
+/* CK_KEY_WRAP_SET_OAEP_PARAMS provides the parameters to the
+ * CKM_KEY_WRAP_SET_OAEP mechanism */
+/* CK_KEY_WRAP_SET_OAEP_PARAMS is new for v2.0 */
+typedef struct CK_KEY_WRAP_SET_OAEP_PARAMS {
+  CK_BYTE       bBC;     /* block contents byte */
+  CK_BYTE_PTR   pX;      /* extra data */
+  CK_ULONG      ulXLen;  /* length of extra data in bytes */
+} CK_KEY_WRAP_SET_OAEP_PARAMS;
+
+typedef CK_KEY_WRAP_SET_OAEP_PARAMS CK_PTR \
+  CK_KEY_WRAP_SET_OAEP_PARAMS_PTR;
+
+
+typedef struct CK_SSL3_RANDOM_DATA {
+  CK_BYTE_PTR  pClientRandom;
+  CK_ULONG     ulClientRandomLen;
+  CK_BYTE_PTR  pServerRandom;
+  CK_ULONG     ulServerRandomLen;
+} CK_SSL3_RANDOM_DATA;
+
+
+typedef struct CK_SSL3_MASTER_KEY_DERIVE_PARAMS {
+  CK_SSL3_RANDOM_DATA RandomInfo;
+  CK_VERSION_PTR pVersion;
+} CK_SSL3_MASTER_KEY_DERIVE_PARAMS;
+
+typedef struct CK_SSL3_MASTER_KEY_DERIVE_PARAMS CK_PTR \
+  CK_SSL3_MASTER_KEY_DERIVE_PARAMS_PTR;
+
+
+typedef struct CK_SSL3_KEY_MAT_OUT {
+  CK_OBJECT_HANDLE hClientMacSecret;
+  CK_OBJECT_HANDLE hServerMacSecret;
+  CK_OBJECT_HANDLE hClientKey;
+  CK_OBJECT_HANDLE hServerKey;
+  CK_BYTE_PTR      pIVClient;
+  CK_BYTE_PTR      pIVServer;
+} CK_SSL3_KEY_MAT_OUT;
+
+typedef CK_SSL3_KEY_MAT_OUT CK_PTR CK_SSL3_KEY_MAT_OUT_PTR;
+
+
+typedef struct CK_SSL3_KEY_MAT_PARAMS {
+  CK_ULONG                ulMacSizeInBits;
+  CK_ULONG                ulKeySizeInBits;
+  CK_ULONG                ulIVSizeInBits;
+  CK_BBOOL                bIsExport;
+  CK_SSL3_RANDOM_DATA     RandomInfo;
+  CK_SSL3_KEY_MAT_OUT_PTR pReturnedKeyMaterial;
+} CK_SSL3_KEY_MAT_PARAMS;
+
+typedef CK_SSL3_KEY_MAT_PARAMS CK_PTR CK_SSL3_KEY_MAT_PARAMS_PTR;
+
+/* CK_TLS_PRF_PARAMS is new for version 2.20 */
+typedef struct CK_TLS_PRF_PARAMS {
+  CK_BYTE_PTR  pSeed;
+  CK_ULONG     ulSeedLen;
+  CK_BYTE_PTR  pLabel;
+  CK_ULONG     ulLabelLen;
+  CK_BYTE_PTR  pOutput;
+  CK_ULONG_PTR pulOutputLen;
+} CK_TLS_PRF_PARAMS;
+
+typedef CK_TLS_PRF_PARAMS CK_PTR CK_TLS_PRF_PARAMS_PTR;
+
+/* WTLS is new for version 2.20 */
+typedef struct CK_WTLS_RANDOM_DATA {
+  CK_BYTE_PTR pClientRandom;
+  CK_ULONG    ulClientRandomLen;
+  CK_BYTE_PTR pServerRandom;
+  CK_ULONG    ulServerRandomLen;
+} CK_WTLS_RANDOM_DATA;
+
+typedef CK_WTLS_RANDOM_DATA CK_PTR CK_WTLS_RANDOM_DATA_PTR;
+
+typedef struct CK_WTLS_MASTER_KEY_DERIVE_PARAMS {
+  CK_MECHANISM_TYPE   DigestMechanism;
+  CK_WTLS_RANDOM_DATA RandomInfo;
+  CK_BYTE_PTR         pVersion;
+} CK_WTLS_MASTER_KEY_DERIVE_PARAMS;
+
+typedef CK_WTLS_MASTER_KEY_DERIVE_PARAMS CK_PTR \
+  CK_WTLS_MASTER_KEY_DERIVE_PARAMS_PTR;
+
+typedef struct CK_WTLS_PRF_PARAMS {
+  CK_MECHANISM_TYPE DigestMechanism;
+  CK_BYTE_PTR       pSeed;
+  CK_ULONG          ulSeedLen;
+  CK_BYTE_PTR       pLabel;
+  CK_ULONG          ulLabelLen;
+  CK_BYTE_PTR       pOutput;
+  CK_ULONG_PTR      pulOutputLen;
+} CK_WTLS_PRF_PARAMS;
+
+typedef CK_WTLS_PRF_PARAMS CK_PTR CK_WTLS_PRF_PARAMS_PTR;
+
+typedef struct CK_WTLS_KEY_MAT_OUT {
+  CK_OBJECT_HANDLE hMacSecret;
+  CK_OBJECT_HANDLE hKey;
+  CK_BYTE_PTR      pIV;
+} CK_WTLS_KEY_MAT_OUT;
+
+typedef CK_WTLS_KEY_MAT_OUT CK_PTR CK_WTLS_KEY_MAT_OUT_PTR;
+
+typedef struct CK_WTLS_KEY_MAT_PARAMS {
+  CK_MECHANISM_TYPE       DigestMechanism;
+  CK_ULONG                ulMacSizeInBits;
+  CK_ULONG                ulKeySizeInBits;
+  CK_ULONG                ulIVSizeInBits;
+  CK_ULONG                ulSequenceNumber;
+  CK_BBOOL                bIsExport;
+  CK_WTLS_RANDOM_DATA     RandomInfo;
+  CK_WTLS_KEY_MAT_OUT_PTR pReturnedKeyMaterial;
+} CK_WTLS_KEY_MAT_PARAMS;
+
+typedef CK_WTLS_KEY_MAT_PARAMS CK_PTR CK_WTLS_KEY_MAT_PARAMS_PTR;
+
+/* CMS is new for version 2.20 */
+typedef struct CK_CMS_SIG_PARAMS {
+  CK_OBJECT_HANDLE      certificateHandle;
+  CK_MECHANISM_PTR      pSigningMechanism;
+  CK_MECHANISM_PTR      pDigestMechanism;
+  CK_UTF8CHAR_PTR       pContentType;
+  CK_BYTE_PTR           pRequestedAttributes;
+  CK_ULONG              ulRequestedAttributesLen;
+  CK_BYTE_PTR           pRequiredAttributes;
+  CK_ULONG              ulRequiredAttributesLen;
+} CK_CMS_SIG_PARAMS;
+
+typedef CK_CMS_SIG_PARAMS CK_PTR CK_CMS_SIG_PARAMS_PTR;
+
+typedef struct CK_KEY_DERIVATION_STRING_DATA {
+  CK_BYTE_PTR pData;
+  CK_ULONG    ulLen;
+} CK_KEY_DERIVATION_STRING_DATA;
+
+typedef CK_KEY_DERIVATION_STRING_DATA CK_PTR \
+  CK_KEY_DERIVATION_STRING_DATA_PTR;
+
+
+/* The CK_EXTRACT_PARAMS is used for the
+ * CKM_EXTRACT_KEY_FROM_KEY mechanism.  It specifies which bit
+ * of the base key should be used as the first bit of the
+ * derived key */
+/* CK_EXTRACT_PARAMS is new for v2.0 */
+typedef CK_ULONG CK_EXTRACT_PARAMS;
+
+typedef CK_EXTRACT_PARAMS CK_PTR CK_EXTRACT_PARAMS_PTR;
+
+/* CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE is new for v2.10.
+ * CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE is used to
+ * indicate the Pseudo-Random Function (PRF) used to generate
+ * key bits using PKCS #5 PBKDF2. */
+typedef CK_ULONG CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE;
+
+typedef CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE CK_PTR CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE_PTR;
+
+/* The following PRFs are defined in PKCS #5 v2.0. */
+#define CKP_PKCS5_PBKD2_HMAC_SHA1 0x00000001
+
+
+/* CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE is new for v2.10.
+ * CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE is used to indicate the
+ * source of the salt value when deriving a key using PKCS #5
+ * PBKDF2. */
+typedef CK_ULONG CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE;
+
+typedef CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE CK_PTR CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE_PTR;
+
+/* The following salt value sources are defined in PKCS #5 v2.0. */
+#define CKZ_SALT_SPECIFIED        0x00000001
+
+/* CK_PKCS5_PBKD2_PARAMS is new for v2.10.
+ * CK_PKCS5_PBKD2_PARAMS is a structure that provides the
+ * parameters to the CKM_PKCS5_PBKD2 mechanism. */
+typedef struct CK_PKCS5_PBKD2_PARAMS {
+        CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE           saltSource;
+        CK_VOID_PTR                                pSaltSourceData;
+        CK_ULONG                                   ulSaltSourceDataLen;
+        CK_ULONG                                   iterations;
+        CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE prf;
+        CK_VOID_PTR                                pPrfData;
+        CK_ULONG                                   ulPrfDataLen;
+        CK_UTF8CHAR_PTR                            pPassword;
+        CK_ULONG_PTR                               ulPasswordLen;
+} CK_PKCS5_PBKD2_PARAMS;
+
+typedef CK_PKCS5_PBKD2_PARAMS CK_PTR CK_PKCS5_PBKD2_PARAMS_PTR;
+
+#endif
diff -urN openssl-0.9.8e/engines/pkcs-11v2-20a3.h openssl-0.9.8e.new/engines/pkcs-11v2-20a3.h
--- openssl-0.9.8e/engines/pkcs-11v2-20a3.h	1970-01-01 10:00:00.000000000 +1000
+++ openssl-0.9.8e.new/engines/pkcs-11v2-20a3.h	2008-06-13 09:45:21.000000000 +1000
@@ -0,0 +1,124 @@
+/* pkcs-11v2-20a3.h include file for the PKCS #11 Version 2.20 Amendment 3
+   document. */
+
+/* $Revision: 1.1 $ */
+
+/* License to copy and use this software is granted provided that it is
+ * identified as "RSA Security Inc. PKCS #11 Cryptographic Token Interface
+ * (Cryptoki) Version 2.20 Amendment 3" in all material mentioning or
+ * referencing this software.
+
+ * RSA Security Inc. makes no representations concerning either the 
+ * merchantability of this software or the suitability of this software for
+ * any particular purpose. It is provided "as is" without express or implied
+ * warranty of any kind.
+ */
+
+/* This file is preferably included after inclusion of pkcs11.h */
+
+#ifndef _PKCS_11V2_20A3_H_
+#define _PKCS_11V2_20A3_H_ 1
+
+/* Are the definitions of this file already included in pkcs11t.h ? */
+#ifndef CKK_CAMELLIA
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Key types */
+
+/* Camellia is new for PKCS #11 v2.20 amendment 3 */
+#define CKK_CAMELLIA                   0x00000025
+/* ARIA is new for PKCS #11 v2.20 amendment 3 */
+#define CKK_ARIA                       0x00000026
+
+
+/* Mask-generating functions */
+
+/* SHA-224 is new for PKCS #11 v2.20 amendment 3 */
+#define CKG_MGF1_SHA224                0x00000005
+
+
+/* Mechanism Identifiers */
+
+/* SHA-224 is new for PKCS #11 v2.20 amendment 3 */
+#define CKM_SHA224                     0x00000255
+#define CKM_SHA224_HMAC                0x00000256
+#define CKM_SHA224_HMAC_GENERAL        0x00000257
+
+/* SHA-224 key derivation is new for PKCS #11 v2.20 amendment 3 */
+#define CKM_SHA224_KEY_DERIVATION      0x00000396
+
+/* SHA-224 RSA mechanisms are new for PKCS #11 v2.20 amendment 3 */
+#define CKM_SHA224_RSA_PKCS            0x00000046
+#define CKM_SHA224_RSA_PKCS_PSS        0x00000047
+
+/* AES counter mode is new for PKCS #11 v2.20 amendment 3 */
+#define CKM_AES_CTR                    0x00001086
+
+/* Camellia is new for PKCS #11 v2.20 amendment 3 */
+#define CKM_CAMELLIA_KEY_GEN           0x00000550
+#define CKM_CAMELLIA_ECB               0x00000551
+#define CKM_CAMELLIA_CBC               0x00000552
+#define CKM_CAMELLIA_MAC               0x00000553
+#define CKM_CAMELLIA_MAC_GENERAL       0x00000554
+#define CKM_CAMELLIA_CBC_PAD           0x00000555
+#define CKM_CAMELLIA_ECB_ENCRYPT_DATA  0x00000556
+#define CKM_CAMELLIA_CBC_ENCRYPT_DATA  0x00000557
+#define CKM_CAMELLIA_CTR               0x00000558
+
+/* ARIA is new for PKCS #11 v2.20 amendment 3 */
+#define CKM_ARIA_KEY_GEN               0x00000560
+#define CKM_ARIA_ECB                   0x00000561
+#define CKM_ARIA_CBC                   0x00000562
+#define CKM_ARIA_MAC                   0x00000563
+#define CKM_ARIA_MAC_GENERAL           0x00000564
+#define CKM_ARIA_CBC_PAD               0x00000565
+#define CKM_ARIA_ECB_ENCRYPT_DATA      0x00000566
+#define CKM_ARIA_CBC_ENCRYPT_DATA      0x00000567
+
+
+/* Mechanism parameters */
+
+/* CK_AES_CTR_PARAMS is new for PKCS #11 v2.20 amendment 3 */
+typedef struct CK_AES_CTR_PARAMS {
+    CK_ULONG ulCounterBits;
+    CK_BYTE cb[16];
+} CK_AES_CTR_PARAMS;
+
+typedef CK_AES_CTR_PARAMS CK_PTR CK_AES_CTR_PARAMS_PTR;
+
+/* CK_CAMELLIA_CTR_PARAMS is new for PKCS #11 v2.20 amendment 3 */
+typedef struct CK_CAMELLIA_CTR_PARAMS {
+    CK_ULONG ulCounterBits;
+    CK_BYTE cb[16];
+} CK_CAMELLIA_CTR_PARAMS;
+
+typedef CK_CAMELLIA_CTR_PARAMS CK_PTR CK_CAMELLIA_CTR_PARAMS_PTR;
+
+/* CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS is new for PKCS #11 v2.20 amendment 3 */
+typedef struct CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS {
+    CK_BYTE      iv[16];
+    CK_BYTE_PTR  pData;
+    CK_ULONG     length;
+} CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS;
+
+typedef CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS CK_PTR CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+/* CK_ARIA_CBC_ENCRYPT_DATA_PARAMS is new for PKCS #11 v2.20 amendment 3 */
+typedef struct CK_ARIA_CBC_ENCRYPT_DATA_PARAMS {
+    CK_BYTE      iv[16];
+    CK_BYTE_PTR  pData;
+    CK_ULONG     length;
+} CK_ARIA_CBC_ENCRYPT_DATA_PARAMS;
+
+typedef CK_ARIA_CBC_ENCRYPT_DATA_PARAMS CK_PTR CK_ARIA_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+#endif
